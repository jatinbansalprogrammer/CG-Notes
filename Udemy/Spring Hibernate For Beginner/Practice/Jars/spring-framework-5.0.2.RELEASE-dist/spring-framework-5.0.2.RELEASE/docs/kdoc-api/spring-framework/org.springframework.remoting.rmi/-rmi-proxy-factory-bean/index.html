<HTML>
<HEAD>
<meta charset="UTF-8">
<title>RmiProxyFactoryBean - spring-framework</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">spring-framework</a>&nbsp;/&nbsp;<a href="../index.html">org.springframework.remoting.rmi</a>&nbsp;/&nbsp;<a href=".">RmiProxyFactoryBean</a><br/>
<br/>
<h1>RmiProxyFactoryBean</h1>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">RmiProxyFactoryBean</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">RmiClientInterceptor</span><span class="symbol">, </span><span class="identifier">FactoryBean</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier">BeanClassLoaderAware</span></code>
<p>FactoryBean for RMI proxies, supporting both conventional RMI services and RMI invokers. Exposes the proxied service for use as a bean reference, using the specified service interface. Proxies will throw Spring's unchecked RemoteAccessException on remote invocation failure instead of RMI's RemoteException. 
<p>The service URL must be a valid RMI URL like "rmi://localhost:1099/myservice". RMI invokers work at the RmiInvocationHandler level, using the same invoker stub for any service. Service interfaces do not have to extend <code>java.rmi.Remote</code> or throw <code>java.rmi.RemoteException</code>. Of course, in and out parameters have to be serializable. </p>
<p>With conventional RMI services, this proxy factory is typically used with the RMI service interface. Alternatively, this factory can also proxy a remote RMI service with a matching non-RMI business interface, i.e. an interface that mirrors the RMI service methods but does not declare RemoteExceptions. In the latter case, RemoteExceptions thrown by the RMI stub will automatically get converted to Spring's unchecked RemoteAccessException. </p>
<p>The major advantage of RMI, compared to Hessian, is serialization. Effectively, any serializable Java object can be transported without hassle. Hessian has its own (de-)serialization mechanisms, but is HTTP-based and thus much easier to setup than RMI. Alternatively, consider Spring's HTTP invoker to combine Java serialization with HTTP-based transport.</p>
</p>
<p><strong>Author</strong><br/>
Juergen Hoeller</p>
<p><strong>Since</strong><br/>
13.05.2003</p>
<p><strong>See Also</strong><br/>
<a href="#">#setServiceInterface</a><a href="#">#setServiceUrl</a>RmiClientInterceptorRmiServiceExporterjava.rmi.Remotejava.rmi.RemoteExceptionorg.springframework.remoting.RemoteAccessExceptionorg.springframework.remoting.caucho.HessianProxyFactoryBeanorg.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean</p>
<h3>Constructors</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-init-.html">&lt;init&gt;</a></p>
</td>
<td>
<code><span class="identifier">RmiProxyFactoryBean</span><span class="symbol">(</span><span class="symbol">)</span></code>
<p>FactoryBean for RMI proxies, supporting both conventional RMI services and RMI invokers. Exposes the proxied service for use as a bean reference, using the specified service interface. Proxies will throw Spring's unchecked RemoteAccessException on remote invocation failure instead of RMI's RemoteException. 
<p>The service URL must be a valid RMI URL like "rmi://localhost:1099/myservice". RMI invokers work at the RmiInvocationHandler level, using the same invoker stub for any service. Service interfaces do not have to extend <code>java.rmi.Remote</code> or throw <code>java.rmi.RemoteException</code>. Of course, in and out parameters have to be serializable. </p>
<p>With conventional RMI services, this proxy factory is typically used with the RMI service interface. Alternatively, this factory can also proxy a remote RMI service with a matching non-RMI business interface, i.e. an interface that mirrors the RMI service methods but does not declare RemoteExceptions. In the latter case, RemoteExceptions thrown by the RMI stub will automatically get converted to Spring's unchecked RemoteAccessException. </p>
<p>The major advantage of RMI, compared to Hessian, is serialization. Effectively, any serializable Java object can be transported without hassle. Hessian has its own (de-)serialization mechanisms, but is HTTP-based and thus much easier to setup than RMI. Alternatively, consider Spring's HTTP invoker to combine Java serialization with HTTP-based transport.</p>
</p>
</td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="after-properties-set.html">afterPropertiesSet</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">afterPropertiesSet</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code></td>
</tr>
<tr>
<td>
<p><a href="get-object.html">getObject</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">getObject</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a></code></td>
</tr>
<tr>
<td>
<p><a href="get-object-type.html">getObjectType</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">getObjectType</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Class</span><span class="symbol">&lt;</span><span class="identifier">*</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="is-singleton.html">isSingleton</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">isSingleton</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
