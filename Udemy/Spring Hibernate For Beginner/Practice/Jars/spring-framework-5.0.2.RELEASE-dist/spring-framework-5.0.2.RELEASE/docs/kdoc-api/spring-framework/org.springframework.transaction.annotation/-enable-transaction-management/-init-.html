<HTML>
<HEAD>
<meta charset="UTF-8">
<title>EnableTransactionManagement.<init> - spring-framework</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">spring-framework</a>&nbsp;/&nbsp;<a href="../index.html">org.springframework.transaction.annotation</a>&nbsp;/&nbsp;<a href="index.html">EnableTransactionManagement</a>&nbsp;/&nbsp;<a href=".">&lt;init&gt;</a><br/>
<br/>
<h1>&lt;init&gt;</h1>
<a name="org.springframework.transaction.annotation.EnableTransactionManagement$&lt;init&gt;(kotlin.Boolean, org.springframework.context.annotation.AdviceMode, kotlin.Int)"></a>
<code><span class="identifier">EnableTransactionManagement</span><span class="symbol">(</span><span class="identifier" id="org.springframework.transaction.annotation.EnableTransactionManagement$<init>(kotlin.Boolean, org.springframework.context.annotation.AdviceMode, kotlin.Int)/proxyTargetClass">proxyTargetClass</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a><span class="symbol">, </span><span class="identifier" id="org.springframework.transaction.annotation.EnableTransactionManagement$<init>(kotlin.Boolean, org.springframework.context.annotation.AdviceMode, kotlin.Int)/mode">mode</span><span class="symbol">:</span>&nbsp;<span class="identifier">AdviceMode</span><span class="symbol">, </span><span class="identifier" id="org.springframework.transaction.annotation.EnableTransactionManagement$<init>(kotlin.Boolean, org.springframework.context.annotation.AdviceMode, kotlin.Int)/order">order</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">)</span></code>
<p>Enables Spring's annotation-driven transaction management capability, similar to the support found in Spring's <code>&lt;tx:*&gt;</code> XML namespace. To be used on org.springframework.context.annotation.Configuration classes as follows: <pre><code> @Configuration @EnableTransactionManagement public class AppConfig { @Bean public FooRepository fooRepository() { // configure and return a class having @Transactional methods return new JdbcFooRepository(dataSource()); } @Bean public DataSource dataSource() { // configure and return the necessary JDBC DataSource } @Bean public PlatformTransactionManager txManager() { return new DataSourceTransactionManager(dataSource()); } }</code></pre> 
<p>For reference, the example above can be compared to the following Spring XML configuration: </p>
<pre><code><code>&lt;beans&gt; &lt;tx:annotation-driven/&gt; &lt;bean id="fooRepository" class="com.foo.JdbcFooRepository"&gt; &lt;constructor-arg ref="dataSource"/&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="com.vendor.VendorDataSource"/&gt; &lt;bean id="transactionManager" class="org.sfwk...DataSourceTransactionManager"&gt; &lt;constructor-arg ref="dataSource"/&gt; &lt;/bean&gt; &lt;/beans&gt; </code></code></pre> In both of the scenarios above, <code>@EnableTransactionManagement</code> and <code>&lt;tx:annotation-driven/&gt;</code> are responsible for registering the necessary Spring components that power annotation-driven transaction management, such as the TransactionInterceptor and the proxy- or AspectJ-based advice that weave the interceptor into the call stack when <code>JdbcFooRepository</code>'s <code>@Transactional</code> methods are invoked. 
<p>A minor difference between the two examples lies in the naming of the <code>PlatformTransactionManager</code> bean: In the <code>@Bean</code> case, the name is <em>"txManager"</em> (per the name of the method); in the XML case, the name is <em>"transactionManager"</em>. The <code>&lt;tx:annotation-driven/&gt;</code> is hard-wired to look for a bean named "transactionManager" by default, however <code>@EnableTransactionManagement</code> is more flexible; it will fall back to a by-type lookup for any <code>PlatformTransactionManager</code> bean in the container. Thus the name can be "txManager", "transactionManager", or "tm": it simply does not matter. </p>
<p>For those that wish to establish a more direct relationship between <code>@EnableTransactionManagement</code> and the exact transaction manager bean to be used, the TransactionManagementConfigurer callback interface may be implemented - notice the <code>implements</code> clause and the <code>@Override</code>-annotated method below: </p>
<pre><code> @Configuration @EnableTransactionManagement public class AppConfig implements TransactionManagementConfigurer { @Bean public FooRepository fooRepository() { // configure and return a class having @Transactional methods return new JdbcFooRepository(dataSource()); } @Bean public DataSource dataSource() { // configure and return the necessary JDBC DataSource } @Bean public PlatformTransactionManager txManager() { return new DataSourceTransactionManager(dataSource()); } @Override public PlatformTransactionManager annotationDrivenTransactionManager() { return txManager(); } }</code></pre> This approach may be desirable simply because it is more explicit, or it may be necessary in order to distinguish between two <code>PlatformTransactionManager</code> beans present in the same container. As the name suggests, the <code>annotationDrivenTransactionManager()</code> will be the one used for processing <code>@Transactional</code> methods. See TransactionManagementConfigurer Javadoc for further details. 
<p>The <code><a href="#">#mode</a></code> attribute controls how advice is applied: If the mode is <code><a href="#">AdviceMode#PROXY</a></code> (the default), then the other attributes control the behavior of the proxying. Please note that proxy mode allows for interception of calls through the proxy only; local calls within the same class cannot get intercepted that way. </p>
<p>Note that if the <a href="#">#mode</a> is set to <code><a href="#">AdviceMode#ASPECTJ</a></code>, then the value of the <code><a href="#">#proxyTargetClass</a></code> attribute will be ignored. Note also that in this case the <code>spring-aspects</code> module JAR must be present on the classpath, with compile-time weaving or load-time weaving applying the aspect to the affected classes. There is no proxy involved in such a scenario; local calls will be intercepted as well.</p>
</p>
<p><strong>Author</strong><br/>
Chris Beams</p>
<p><strong>Author</strong><br/>
Juergen Hoeller</p>
<p><strong>Since</strong><br/>
3.1</p>
<p><strong>See Also</strong><br/>
TransactionManagementConfigurerTransactionManagementConfigurationSelectorProxyTransactionManagementConfigurationorg.springframework.transaction.aspectj.AspectJTransactionManagementConfiguration</p>
</BODY>
</HTML>
