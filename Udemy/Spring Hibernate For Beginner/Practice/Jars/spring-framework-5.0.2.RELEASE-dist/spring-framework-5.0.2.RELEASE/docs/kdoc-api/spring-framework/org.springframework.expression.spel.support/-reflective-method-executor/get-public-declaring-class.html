<HTML>
<HEAD>
<meta charset="UTF-8">
<title>ReflectiveMethodExecutor.getPublicDeclaringClass - spring-framework</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">spring-framework</a>&nbsp;/&nbsp;<a href="../index.html">org.springframework.expression.spel.support</a>&nbsp;/&nbsp;<a href="index.html">ReflectiveMethodExecutor</a>&nbsp;/&nbsp;<a href=".">getPublicDeclaringClass</a><br/>
<br/>
<h1>getPublicDeclaringClass</h1>
<a name="org.springframework.expression.spel.support.ReflectiveMethodExecutor$getPublicDeclaringClass()"></a>
<code><span class="identifier">@Nullable</span> <span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">getPublicDeclaringClass</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Class</span><span class="symbol">&lt;</span><span class="identifier">*</span><span class="symbol">&gt;</span></code>
<p>Find the first public class in the methods declaring class hierarchy that declares this method. Sometimes the reflective method discovery logic finds a suitable method that can easily be called via reflection but cannot be called from generated code when compiling the expression because of visibility restrictions. For example if a non public class overrides toString(), this helper method will walk up the type hierarchy to find the first public type that declares the method (if there is one!). For toString() it may walk as far as Object.</p>
</BODY>
</HTML>
