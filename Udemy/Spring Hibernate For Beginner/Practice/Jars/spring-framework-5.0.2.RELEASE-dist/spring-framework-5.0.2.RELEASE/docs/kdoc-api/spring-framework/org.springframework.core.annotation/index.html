<HTML>
<HEAD>
<meta charset="UTF-8">
<title>org.springframework.core.annotation - spring-framework</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">spring-framework</a>&nbsp;/&nbsp;<a href=".">org.springframework.core.annotation</a><br/>
<br/>
<h2>Package org.springframework.core.annotation</h2>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-annotated-element-utils/index.html">AnnotatedElementUtils</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">AnnotatedElementUtils</span></code>
<p>General utility methods for finding annotations, meta-annotations, and repeatable annotations on AnnotatedElement. 
<p><code>AnnotatedElementUtils</code> defines the public API for Spring's meta-annotation programming model with support for <em>annotation attribute overrides</em>. If you do not need support for annotation attribute overrides, consider using AnnotationUtils instead. </p>
<p>Note that the features of this class are not provided by the JDK's introspection facilities themselves. </p>
Annotation Attribute Overrides 
<p>Support for meta-annotations with <em>attribute overrides</em> in <em>composed annotations</em> is provided by all variants of the <code>getMergedAnnotationAttributes()</code>, <code>getMergedAnnotation()</code>, <code>getAllMergedAnnotations()</code>, <code>getMergedRepeatableAnnotations()</code>, <code>findMergedAnnotationAttributes()</code>, <code>findMergedAnnotation()</code>, <code>findAllMergedAnnotations()</code>, and <code>findMergedRepeatableAnnotations()</code> methods. </p>
Find vs. Get Semantics 
<p>The search algorithms used by methods in this class follow either <em>find</em> or <em>get</em> semantics. Consult the javadocs for each individual method for details on which search algorithm is used. </p>
<p><strong>Get semantics</strong> are limited to searching for annotations that are either <em>present</em> on an <code>AnnotatedElement</code> (i.e., declared locally or java.lang.annotation.Inherited) or declared within the annotation hierarchy <em>above</em> the <code>AnnotatedElement</code>. </p>
<p><strong>Find semantics</strong> are much more exhaustive, providing <em>get semantics</em> plus support for the following: </p>
<ul> <li>Searching on interfaces, if the annotated element is a class </li>
<li>Searching on superclasses, if the annotated element is a class </li>
<li>Resolving bridged methods, if the annotated element is a method </li>
<li>Searching on methods in interfaces, if the annotated element is a method </li>
<li>Searching on methods in superclasses, if the annotated element is a method </li>
</ul>
 Support for <code>@Inherited</code> 
<p>Methods following <em>get semantics</em> will honor the contract of Java's java.lang.annotation.Inherited annotation except that locally declared annotations (including custom composed annotations) will be favored over inherited annotations. In contrast, methods following <em>find semantics</em> will completely ignore the presence of <code>@Inherited</code> since the <em>find</em> search algorithm manually traverses type and method hierarchies and thereby implicitly supports annotation inheritance without the need for <code>@Inherited</code>.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="-order-utils/index.html">OrderUtils</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">OrderUtils</span></code>
<p>General utility for determining the order of an object based on its type declaration. Handles Spring's Order annotation as well as javax.annotation.Priority.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-synthesized-annotation.html">SynthesizedAnnotation</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">SynthesizedAnnotation</span></code>
<p>Marker interface implemented by synthesized annotation proxies. 
<p>Used to detect whether an annotation has already been synthesized.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="-synthesizing-method-parameter/index.html">SynthesizingMethodParameter</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">SynthesizingMethodParameter</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">MethodParameter</span></code>
<p>A MethodParameter variant which synthesizes annotations that declare attribute aliases via AliasFor.</p>
</td>
</tr>
</tbody>
</table>
<h3>Annotations</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-order/index.html">Order</a></p>
</td>
<td>
<code><span class="keyword">class </span><span class="identifier">Order</span></code>
<p><code>@Order</code> defines the sort order for an annotated component. 
<p>The <code><a href="#">#value</a></code> is optional and represents an order value as defined in the Ordered interface. Lower values have higher priority. The default value is <code>Ordered.LOWEST_PRECEDENCE</code>, indicating lowest priority (losing to any other specified order value). </p>
<p><strong>NOTE:</strong> Since Spring 4.0, annotation-based ordering is supported for many kinds of components in Spring, even for collection injection where the order values of the target components are taken into account (either from their target class or from their <code>@Bean</code> method). While such order values may influence priorities at injection points, please be aware that they do not influence singleton startup order which is an orthogonal concern determined by dependency relationships and <code>@DependsOn</code> declarations (influencing a runtime-determined dependency graph). </p>
<p>Since Spring 4.1, the standard javax.annotation.Priority annotation can be used as a drop-in replacement for this annotation in ordering scenarios. Note that <code>Priority</code> may have additional semantics when a single element has to be picked (see <code><a href="#">AnnotationAwareOrderComparator#getPriority</a></code>). </p>
<p>Alternatively, order values may also be determined on a per-instance basis through the Ordered interface, allowing for configuration-determined instance values instead of hard-coded values attached to a particular class. </p>
<p>Consult the javadoc for org.springframework.core.OrderComparator for details on the sort semantics for non-ordered objects.</p>
</p>
</td>
</tr>
</tbody>
</table>
<h3>Exceptions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-annotation-configuration-exception/index.html">AnnotationConfigurationException</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">AnnotationConfigurationException</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">NestedRuntimeException</span></code>
<p>Thrown by AnnotationUtils and <em>synthesized annotations</em> if an annotation is improperly configured.</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
