<HTML>
<HEAD>
<meta charset="UTF-8">
<title>org.springframework.test.util - spring-framework</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">spring-framework</a>&nbsp;/&nbsp;<a href=".">org.springframework.test.util</a><br/>
<br/>
<h2>Package org.springframework.test.util</h2>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-reflection-test-utils/index.html">ReflectionTestUtils</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">ReflectionTestUtils</span></code>
<p><code>ReflectionTestUtils</code> is a collection of reflection-based utility methods for use in unit and integration testing scenarios. 
<p>There are often times when it would be beneficial to be able to set a non-<code>public</code> field, invoke a non-<code>public</code> setter method, or invoke a non-<code>public</code> <em>configuration</em> or <em>lifecycle</em> callback method when testing code involving, for example: </p>
<ul> <li>ORM frameworks such as JPA and Hibernate which condone the usage of <code>private</code> or <code>protected</code> field access as opposed to <code>public</code> setter methods for properties in a domain entity.</li>
 <li>Spring's support for annotations such as org.springframework.beans.factory.annotation.Autowired, javax.inject.Inject, and javax.annotation.Resource which provides dependency injection for <code>private</code> or <code>protected</code> fields, setter methods, and configuration methods.</li>
 <li>Use of annotations such as javax.annotation.PostConstruct and javax.annotation.PreDestroy for lifecycle callback methods.</li>
 </ul>
 
<p>In addition, several methods in this class provide support for <code>static</code> fields â€” for example, <code><a href="#">#setField(Class, String, Object)</a></code>, <code><a href="#">#getField(Class, String)</a></code>, etc.</p>
</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
