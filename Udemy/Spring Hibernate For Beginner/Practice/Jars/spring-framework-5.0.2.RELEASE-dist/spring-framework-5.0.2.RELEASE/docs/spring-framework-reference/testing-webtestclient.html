<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>WebTestClient</title>
<style>
/* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
/* ===================================================================== */

@import url('stylesheets/asciidoctor-spring.css');

/* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
/* ============================================================================ */

@import url('tocbot-3.0.2/tocbot.css');

#tocbot a.toc-link.node-name--H1{ font-style: italic }
@media screen{
#tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
#tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
  padding-left: 0 }
#tocbot a.toc-link{ height:100% }
.is-collapsible{ max-height:3000px; overflow:hidden; }
.is-collapsed{ max-height:0 }
.is-active-link{ font-weight:700 }
}
@media print{
#tocbot a.toc-link.node-name--H4{ display:none }
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body id="webtestclient" class="book">
<div id="header">
<h1>WebTestClient</h1>
<div class="details">
<span id="revnumber">version 5.0.2.RELEASE</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><code>WebTestClient</code> is a non-blocking, reactive client for testing web servers. It uses
the reactive <a href="web-reactive.html#webflux-webclient">WebClient</a> internally to perform
requests and provides a fluent API to verify responses. The <code>WebTestClient</code> can connect
to any server over an HTTP connection. It can also bind directly to WebFlux applications
with <a href="testing.html#mock-objects-web-reactive">mock request and response</a> objects,
without the need for an HTTP server.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>WebTestClient</code> is not usable yet in Kotlin, see <a href="languages.html#kotlin-webtestclient-issue">this section</a> for more details.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webtestclient-setup"><a class="anchor" href="#webtestclient-setup"></a>1. Setup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To create a <code>WebTestClient</code> you must choose one of several server setup options.
Effectively you either configure a WebFlux application to bind to, or use absolute URLs
to connect to a running server.</p>
</div>
<div class="sect2">
<h3 id="webtestclient-controller-config"><a class="anchor" href="#webtestclient-controller-config"></a>1.1. Bind to controller</h3>
<div class="paragraph">
<p>Use this server setup to test one <code>@Controller</code> at a time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        client = WebTestClient.bindToController(<span class="keyword">new</span> TestController()).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above loads the <a href="web-reactive.html#webflux-config">WebFlux Java config</a> and
registers the given controller. The resulting WebFlux application will be tested
without an HTTP server using mock request and response objects. There are more methods
on the builder to customize the default WebFlux Java config.</p>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-fn-config"><a class="anchor" href="#webtestclient-fn-config"></a>1.2. Bind to RouterFunction</h3>
<div class="paragraph">
<p>Use this option to set up a server from a
<a href="web-reactive.html#webflux-fn">RouterFunction</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        RouterFunction&lt;?&gt; route = ...
        client = WebTestClient.bindToRouterFunction(route).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Internally the provided configuration is passed to <code>RouterFunctions.toWebHandler</code>.
The resulting WebFlux application will be tested without an HTTP server using mock
request and response objects.</p>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-context-config"><a class="anchor" href="#webtestclient-context-config"></a>1.3. Bind to ApplicationContext</h3>
<div class="paragraph">
<p>Use this option to setup a server from the Spring configuration of your application, or
some subset of it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="annotation">@RunWith</span>(SpringRunner.class)
        <span class="annotation">@ContextConfiguration</span>(classes = WebConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="directive">public</span> <span class="type">class</span> <span class="class">MyTests</span> {

                <span class="annotation">@Autowired</span>
                <span class="directive">private</span> ApplicationContext context; <i class="conum" data-value="2"></i><b>(2)</b>

                <span class="directive">private</span> WebTestClient client;

                <span class="annotation">@Before</span>
                <span class="directive">public</span> <span class="type">void</span> setUp() {
                        client = WebTestClient.bindToApplicationContext(context).build(); <i class="conum" data-value="3"></i><b>(3)</b>
                }
        }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the configuration to load</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Inject the configuration</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create the <code>WebTestClient</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Internally the provided configuration is passed to <code>WebHttpHandlerBuilder</code> to set up
the request processing chain, see
<a href="web-reactive.html#webflux-web-handler-api">WebHandler API</a> for more details. The
resulting WebFlux application will be tested without an HTTP server using mock request
and response objects.</p>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-server-config"><a class="anchor" href="#webtestclient-server-config"></a>1.4. Bind to server</h3>
<div class="paragraph">
<p>This server setup option allows you to connect to a running server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        client = WebTestClient.bindToServer().baseUrl(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8080</span><span class="delimiter">&quot;</span></span>).build();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-client-config"><a class="anchor" href="#webtestclient-client-config"></a>1.5. Client builder</h3>
<div class="paragraph">
<p>In addition to the server setup options above, you can also configure client
options including base URL, default headers, client filters, and others. These options
are readily available following <code>bindToServer</code>. For all others, you need to use
<code>configureClient()</code> to transition from server to client configuration as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        client = WebTestClient.bindToController(<span class="keyword">new</span> TestController())
                        .configureClient()
                        .baseUrl(<span class="string"><span class="delimiter">&quot;</span><span class="content">/test</span><span class="delimiter">&quot;</span></span>)
                        .build();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webtestclient-tests"><a class="anchor" href="#webtestclient-tests"></a>2. Writing tests</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>WebTestClient</code> is a thin shell around <a href="web-reactive.html#webflux-webclient">WebClient</a>.
It provides an identical API up to the point of performing a request via <code>exchange()</code>.
What follows after <code>exchange()</code> is a chained API workflow to verify responses.</p>
</div>
<div class="paragraph">
<p>Typically you start by asserting the response status and headers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        client.get().uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/1</span><span class="delimiter">&quot;</span></span>)
                        .accept(MediaType.APPLICATION_JSON_UTF8)
                        .exchange()
                        .expectStatus().isOk()
                        .expectHeader().contentType(MediaType.APPLICATION_JSON_UTF8)
                        <span class="comment">// ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you specify how to decode and consume the response body:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectBody(Class&lt;T&gt;)</code>&#8201;&#8212;&#8201;decode to single object.</p>
</li>
<li>
<p><code>expectBodyList(Class&lt;T&gt;)</code>&#8201;&#8212;&#8201;decode and collect objects to <code>List&lt;T&gt;</code>.</p>
</li>
<li>
<p><code>expectBody()</code>&#8201;&#8212;&#8201;decode to <code>byte[]</code> for <a href="#webtestclient-json">JSON content</a> or empty body.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Then you can use built-in assertions for the body. Here is one example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        client.get().uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons</span><span class="delimiter">&quot;</span></span>)
                        .exchange()
                        .expectStatus().isOk()
                        .expectBodyList(Person.class).hasSize(<span class="integer">3</span>).contains(person);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can go beyond the built-in assertions and create your own:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	client.get().uri("/persons/1")
			.exchange()
			.expectStatus().isOk()
			.expectBody(Person.class)
			.consumeWith(result -&gt; {
				// custom assertions (e.g. AssertJ)...
			});</pre>
</div>
</div>
<div class="paragraph">
<p>You can also exit the workflow and get a result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	EntityExchangeResult&lt;Person&gt; result = client.get().uri("/persons/1")
			.exchange()
			.expectStatus().isOk()
			.expectBody(Person.class)
			.returnResult();</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When you need to decode to a target type with generics, look for the overloaded methods
that accept
{api-spring-framework}/core/ParameterizedTypeReference.html[ParameterizedTypeReference]
instead of <code>Class&lt;T&gt;</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="webtestclient-no-content"><a class="anchor" href="#webtestclient-no-content"></a>2.1. No content</h3>
<div class="paragraph">
<p>If the response has no content, or you don&#8217;t care if it does, use <code>Void.class</code> which ensures
that resources are released:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        client.get().uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/123</span><span class="delimiter">&quot;</span></span>)
                        .exchange()
                        .expectStatus().isNotFound()
                        .expectBody(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or if you want to assert there is no response content, use this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        client.post().uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons</span><span class="delimiter">&quot;</span></span>)
                        .body(personMono, Person.class)
                        .exchange()
                        .expectStatus().isCreated()
                        .expectBody().isEmpty;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-json"><a class="anchor" href="#webtestclient-json"></a>2.2. JSON content</h3>
<div class="paragraph">
<p>When you use <code>expectBody()</code> the response is consumed as a <code>byte[]</code>. This is useful for
raw content assertions. For example you can use
<a href="http://jsonassert.skyscreamer.org">JSONAssert</a> to verify JSON content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        client.get().uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/1</span><span class="delimiter">&quot;</span></span>)
                        .exchange()
                        .expectStatus().isOk()
                        .expectBody()
                        .json(<span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="char">\&quot;</span><span class="content">name</span><span class="char">\&quot;</span><span class="content">:</span><span class="char">\&quot;</span><span class="content">Jane</span><span class="char">\&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use <a href="https://github.com/jayway/JsonPath">JSONPath</a> expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        client.get().uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons</span><span class="delimiter">&quot;</span></span>)
                        .exchange()
                        .expectStatus().isOk()
                        .expectBody()
                        .jsonPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">$[0].name</span><span class="delimiter">&quot;</span></span>).isEqualTo(<span class="string"><span class="delimiter">&quot;</span><span class="content">Jane</span><span class="delimiter">&quot;</span></span>)
                        .jsonPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">$[1].name</span><span class="delimiter">&quot;</span></span>).isEqualTo(<span class="string"><span class="delimiter">&quot;</span><span class="content">Jason</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-stream"><a class="anchor" href="#webtestclient-stream"></a>2.3. Streaming responses</h3>
<div class="paragraph">
<p>To test infinite streams (e.g. <code>"text/event-stream"</code>, <code>"application/stream+json"</code>),
you&#8217;ll need to exit the chained API, via <code>returnResult</code>, immediately after response status
and header assertions, as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        FluxExchangeResult&lt;MyEvent&gt; result = client.get().uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/events</span><span class="delimiter">&quot;</span></span>)
                        .accept(TEXT_EVENT_STREAM)
                        .exchange()
                        .expectStatus().isOk()
                        .returnResult(MyEvent.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can consume the <code>Flux&lt;T&gt;</code>, assert decoded objects as they come, and then
cancel at some point when test objects are met. We recommend using the <code>StepVerifier</code>
from the <code>reactor-test</code> module to do that, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        Flux&lt;<span class="predefined-type">Event</span>&gt; eventFux = result.getResponseBody();

        StepVerifier.create(eventFlux)
                        .expectNext(person)
                        .expectNextCount(<span class="integer">4</span>)
                        .consumeNextWith(p -&gt; ...)
                        .thenCancel()
                        .verify();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-request-body"><a class="anchor" href="#webtestclient-request-body"></a>2.4. Request body</h3>
<div class="paragraph">
<p>When it comes to building requests, the <code>WebTestClient</code> offers an identical API as the
<code>WebClient</code> and the implementation is mostly a simple pass-through. Please refer
to the <a href="web-reactive.html#webflux-client-body">WebClient documentation</a> for examples on
how to prepare a request with a body including submitting form data, multipart requests,
and more.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.0.2.RELEASE<br>
Last updated 2017-11-27 10:24:45 UTC
</div>
</div>
</body>
</html>