<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Web on Reactive Stack</title>
<style>
/* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
/* ===================================================================== */

@import url('stylesheets/asciidoctor-spring.css');

/* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
/* ============================================================================ */

@import url('tocbot-3.0.2/tocbot.css');

#tocbot a.toc-link.node-name--H1{ font-style: italic }
@media screen{
#tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
#tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
  padding-left: 0 }
#tocbot a.toc-link{ height:100% }
.is-collapsible{ max-height:3000px; overflow:hidden; }
.is-collapsed{ max-height:0 }
.is-active-link{ font-weight:700 }
}
@media print{
#tocbot a.toc-link.node-name--H4{ display:none }
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body id="spring-web-reactive" class="book toc2 toc-left">
<div id="header">
<h1>Web on Reactive Stack</h1>
<div class="details">
<span id="revnumber">version 5.0.2.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#webflux">1. Spring WebFlux</a>
<ul class="sectlevel2">
<li><a href="#webflux-introduction">1.1. Introduction</a>
<ul class="sectlevel3">
<li><a href="#webflux-new-framework">1.1.1. Why a new web framework?</a></li>
<li><a href="#webflux-why-reactive">1.1.2. Reactive: what and why?</a></li>
<li><a href="#webflux-reactive-api">1.1.3. Reactive API</a></li>
<li><a href="#webflux-programming-models">1.1.4. Programming models</a></li>
<li><a href="#webflux-framework-choice">1.1.5. Choosing a web framework</a></li>
<li><a href="#webflux-server-choice">1.1.6. Choosing a server</a></li>
<li><a href="#webflux-performance">1.1.7. Performance vs scale</a></li>
</ul>
</li>
<li><a href="#webflux-reactive-spring-web">1.2. Reactive Spring Web</a>
<ul class="sectlevel3">
<li><a href="#webflux-httphandler">1.2.1. HttpHandler</a></li>
<li><a href="#webflux-web-handler-api">1.2.2. WebHandler API</a></li>
<li><a href="#webflux-codecs">1.2.3. Codecs</a></li>
</ul>
</li>
<li><a href="#webflux-dispatcher-handler">1.3. DispatcherHandler</a>
<ul class="sectlevel3">
<li><a href="#webflux-special-bean-types">1.3.1. Special bean types</a></li>
<li><a href="#webflux-framework-config">1.3.2. Framework Config</a></li>
<li><a href="#webflux-dispatcher-handler-sequence">1.3.3. Processing</a></li>
</ul>
</li>
<li><a href="#webflux-controller">1.4. Annotated Controllers</a>
<ul class="sectlevel3">
<li><a href="#webflux-ann-controller">1.4.1. @Controller</a></li>
<li><a href="#webflux-ann-requestmapping">1.4.2. Request Mapping</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-requestmapping-uri-templates">URI Patterns</a></li>
<li><a href="#webflux-ann-requestmapping-pattern-comparison">Pattern Comparison</a></li>
<li><a href="#webflux-ann-requestmapping-consumes">Consumable Media Types</a></li>
<li><a href="#webflux-ann-requestmapping-produces">Producible Media Types</a></li>
<li><a href="#webflux-ann-requestmapping-params-and-headers">Parameters and Headers</a></li>
<li><a href="#webflux-ann-requestmapping-head-options">HTTP HEAD, OPTIONS</a></li>
</ul>
</li>
<li><a href="#webflux-ann-methods">1.4.3. Handler methods</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-arguments">Method arguments</a></li>
<li><a href="#webflux-ann-return-types">Return values</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-fn">1.5. Functional Endpoints</a>
<ul class="sectlevel3">
<li><a href="#webflux-fn-handler-functions">1.5.1. HandlerFunction</a></li>
<li><a href="#webflux-fn-router-functions">1.5.2. RouterFunction</a></li>
<li><a href="#webflux-fn-running">1.5.3. Running a server</a></li>
<li><a href="#webflux-fn-handler-filter-function">1.5.4. HandlerFilterFunction</a></li>
</ul>
</li>
<li><a href="#webflux-config">1.6. WebFlux Java Config</a>
<ul class="sectlevel3">
<li><a href="#webflux-config-enable">1.6.1. Enable WebFlux config</a></li>
<li><a href="#webflux-config-customize">1.6.2. WebFlux config API</a></li>
<li><a href="#webflux-config-conversion">1.6.3. Conversion, formatting</a></li>
<li><a href="#webflux-config-validation">1.6.4. Validation</a></li>
<li><a href="#webflux-config-content-negotiation">1.6.5. Content type resolvers</a></li>
<li><a href="#webflux-config-message-codecs">1.6.6. HTTP message codecs</a></li>
<li><a href="#webflux-config-view-resolvers">1.6.7. View resolvers</a></li>
<li><a href="#webflux-config-static-resources">1.6.8. Static resources</a></li>
<li><a href="#webflux-config-path-matching">1.6.9. Path Matching</a></li>
<li><a href="#webflux-config-advanced-java">1.6.10. Advanced config mode</a></li>
</ul>
</li>
<li><a href="#webflux-cors">1.7. CORS</a>
<ul class="sectlevel3">
<li><a href="#introduction">1.7.1. Introduction</a></li>
<li><a href="#webflux-cors-controller">1.7.2. @CrossOrigin</a></li>
<li><a href="#webflux-cors-java-config">1.7.3. Java Config</a></li>
<li><a href="#webflux-cors-webfilter">1.7.4. CORS WebFilter</a></li>
<li><a href="#webflux-cors-customizations">1.7.5. Advanced Customization</a></li>
</ul>
</li>
<li><a href="#webflux-http2">1.8. HTTP/2</a></li>
</ul>
</li>
<li><a href="#webflux-client">2. WebClient</a>
<ul class="sectlevel2">
<li><a href="#webflux-client-retrieve">2.1. Retrieve</a></li>
<li><a href="#webflux-client-exchange">2.2. Exchange</a></li>
<li><a href="#webflux-client-body">2.3. Request body</a>
<ul class="sectlevel3">
<li><a href="#webflux-client-body-form">2.3.1. Form data</a></li>
<li><a href="#webflux-client-body-multipart">2.3.2. Multipart data</a></li>
</ul>
</li>
<li><a href="#webflux-client-builder">2.4. Builder options</a></li>
<li><a href="#webflux-client-filter">2.5. Filters</a></li>
</ul>
</li>
<li><a href="#webflux-websocket">3. WebSockets</a>
<ul class="sectlevel2">
<li><a href="#websocket-intro">3.1. Introduction</a>
<ul class="sectlevel3">
<li><a href="#websocket-intro-architecture">3.1.1. HTTP vs WebSocket</a></li>
<li><a href="#websocket-intro-when-to-use">3.1.2. When to use it?</a></li>
</ul>
</li>
<li><a href="#webflux-websocket-server">3.2. WebSocket API</a>
<ul class="sectlevel3">
<li><a href="#webflux-websocket-server-handler">3.2.1. WebSocketHandler</a></li>
<li><a href="#webflux-websocket-server-handshake">3.2.2. WebSocket Handshake</a></li>
<li><a href="#webflux-websocket-server-config">3.2.3. Server config</a></li>
<li><a href="#webflux-websocket-server-cors">3.2.4. CORS</a></li>
</ul>
</li>
<li><a href="#webflux-websocket-client">3.3. WebSocketClient</a></li>
</ul>
</li>
<li><a href="#webflux-test">4. Testing</a></li>
<li><a href="#webflux-reactive-libraries">5. Reactive Libraries</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This part of the documentation covers support for reactive stack, web applications built on a
<a href="http://www.reactive-streams.org/">Reactive Streams</a> API to run on non-blocking
servers such as Netty, Undertow, and Servlet 3.1+ containers. Individual chapters cover
the <a href="#webflux-module">Spring WebFlux</a> framework,
the reactive <a href="#webflux-client">WebClient</a>, support for <a href="#webflux-test">Testing</a>,
and <a href="#webflux-reactive-libraries">Reactive Libraries</a>. For Servlet stack, web applications, please see
<a href="web.html#spring-web">Web on Servlet Stack</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux"><a class="anchor" href="#webflux"></a>1. Spring WebFlux</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="webflux-introduction"><a class="anchor" href="#webflux-introduction"></a>1.1. Introduction</h3>
<div class="paragraph">
<p>The original web framework included in the Spring Framework, Spring Web MVC, was purpose
built for the Servlet API and Servlet containers. The reactive stack, web framework,
Spring WebFlux, was added later in version 5.0. It is fully non-blocking, supports
<a href="http://www.reactive-streams.org/">Reactive Streams</a> back pressure, and runs on servers such as
Netty, Undertow, and Servlet 3.1+ containers.</p>
</div>
<div class="paragraph">
<p>Both web frameworks mirror the names of their source modules
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a> and
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a>
and co-exist side by side in the Spring Framework. Each module is optional.
Applications may use one or the other module, or in some cases both&#8201;&#8212;&#8201;e.g. Spring MVC controllers with the reactive <code>WebClient</code>.</p>
</div>
<div class="sect3">
<h4 id="webflux-new-framework"><a class="anchor" href="#webflux-new-framework"></a>1.1.1. Why a new web framework?</h4>
<div class="paragraph">
<p>Part of the answer is the need for a non-blocking web stack to handle concurrency with a
small number of threads and scale with less hardware resources. Servlet 3.1 did provide
an API for non-blocking I/O. However, using it leads away from the rest of the Servlet API
where contracts are synchronous (<code>Filter</code>, <code>Servlet</code>) or blocking (<code>getParameter</code>,
<code>getPart</code>). This was the motivation for a new common API to serve as a foundation across
any non-blocking runtime. That is important because of servers such as Netty that are well
established in the async, non-blocking space.</p>
</div>
<div class="paragraph">
<p>The other part of the answer is functional programming. Much like the addition of annotations
in Java 5 created opportunities&#8201;&#8212;&#8201;e.g. annotated REST controllers or unit tests, the addition
of lambda expressions in Java 8 created opportunities for functional APIs in Java.
This is a boon for non-blocking applications and continuation style APIs&#8201;&#8212;&#8201;as popularized
by <code>CompletableFuture</code> and <a href="http://reactivex.io/">ReactiveX</a>, that allow declarative
composition of asynchronous logic. At the programming model level Java 8 enabled Spring
WebFlux to offer functional web endpoints alongside with annotated controllers.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-why-reactive"><a class="anchor" href="#webflux-why-reactive"></a>1.1.2. Reactive: what and why?</h4>
<div class="paragraph">
<p>We touched on non-blocking and functional but why reactive and what do we mean?</p>
</div>
<div class="paragraph">
<p>The term "reactive" refers to programming models that are built around reacting to change&#8201;&#8212;&#8201;network component reacting to I/O events, UI controller reacting to mouse events, etc.
In that sense non-blocking is reactive because instead of being blocked we are now in the mode
of reacting to notifications as operations complete or data becomes available.</p>
</div>
<div class="paragraph">
<p>There is also another important mechanism that we on the Spring team associate with "reactive"
and that is non-blocking back pressure. In synchronous, imperative code, blocking calls
serve as a natural form of back pressure that forces the caller to wait. In non-blocking
code it becomes important to control the rate of events so that a fast producer does not
overwhelm its destination.</p>
</div>
<div class="paragraph">
<p>Reactive Streams is a
<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#specification">small spec</a>,
also <a href="http://download.java.net/java/jdk9/docs/api/java/util/concurrent/Flow.html">adopted</a> in Java 9,
that defines the interaction between asynchronous components with back pressure.
For example a data repository&#8201;&#8212;&#8201;acting as
<a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html">Publisher</a>,
can produce data that an HTTP server&#8201;&#8212;&#8201;acting as
<a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html">Subscriber</a>,
can then write to the response. The main purpose of Reactive Streams is to allow the
subscriber to control how fast or how slow the publisher will produce data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Common question: what if a publisher can&#8217;t slow down?</strong><br>
The purpose of Reactive Streams is only to establish the mechanism and a boundary.
If a publisher can&#8217;t slow down then it has to decide whether to buffer, drop, or fail.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-reactive-api"><a class="anchor" href="#webflux-reactive-api"></a>1.1.3. Reactive API</h4>
<div class="paragraph">
<p>Reactive Streams plays an important role for interoperability. It is of interest to libraries
and infrastructure components but less useful as an application API because it is too
low level. What applications need is a higher level and richer, functional API to
compose async logic&#8201;&#8212;&#8201;similar to the Java 8 <code>Stream</code> API but not only for collections.
This is the role that reactive libraries play.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor">Reactor</a> is the reactive library of choice for
Spring WebFlux. It provides the
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> and
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> API types
to work on data sequences of 0..1 and 0..N through a rich set of operators aligned with the
ReactiveX <a href="http://reactivex.io/documentation/operators.html">vocabulary of operators</a>.
Reactor is a Reactive Streams library and therefore all of its operators support non-blocking back pressure.
Reactor has a strong focus on server-side Java. It is developed in close collaboration
with Spring.</p>
</div>
<div class="paragraph">
<p>WebFlux requires Reactor as a core dependency but it is interoperable with other reactive
libraries via Reactive Streams. As a general rule WebFlux APIs accept a plain <code>Publisher</code>
as input, adapt it to Reactor types internally, use those, and then return either
<code>Flux</code> or <code>Mono</code> as output. So you can pass any <code>Publisher</code> as input and you can apply
operations on the output, but you&#8217;ll need to adapt the output for use with another reactive library.
Whenever feasible&#8201;&#8212;&#8201;e.g. annotated controllers, WebFlux adapts transparently to the use
of RxJava or other reactive library. See <a href="#webflux-reactive-libraries">Reactive Libraries</a> for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-programming-models"><a class="anchor" href="#webflux-programming-models"></a>1.1.4. Programming models</h4>
<div class="paragraph">
<p>The <code>spring-web</code> module contains the reactive foundation that underlies Spring WebFlux&#8201;&#8212;&#8201;HTTP abstractions, Reactive Streams server adapters, reactive codecs, and a
core Web API whose role is comparable to the Servlet API but with non-blocking semantics.</p>
</div>
<div class="paragraph">
<p>On that foundation Spring WebFlux provides a choice of two programming models:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-controller">Annotated Controllers</a>&#8201;&#8212;&#8201;consistent with Spring MVC, and based on the same annotations
from the <code>spring-web</code> module. Both Spring MVC and WebFlux controllers support reactive
(Reactor, RxJava) return types and as a result it is not easy to tell them apart. One notable
difference is that WebFlux also supports reactive <code>@RequestBody</code> arguments.</p>
</li>
<li>
<p><a href="#webflux-fn">Functional Endpoints</a>&#8201;&#8212;&#8201;lambda-based, lightweight, functional programming model. Think of
this as a small library or a set of utilities that an application can use to route and
handle requests. The big difference with annotated controllers is that the application
is in charge of request handling from start to finish vs declaring intent through
annotations and being called back.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-framework-choice"><a class="anchor" href="#webflux-framework-choice"></a>1.1.5. Choosing a web framework</h4>
<div class="paragraph">
<p>Should you use Spring MVC or WebFlux? Let&#8217;s cover a few different perspectives.</p>
</div>
<div class="paragraph">
<p>If you have a Spring MVC application that works fine, there is no need to change.
Imperative programming is the easiest way to write, understand, and debug code.
You have maximum choice of libraries since historically most are blocking.</p>
</div>
<div class="paragraph">
<p>If you are already shopping for a non-blocking web stack, Spring WebFlux offers the same
execution model benefits as others in this space and also provides a choice of servers&#8201;&#8212;&#8201;Netty, Tomcat, Jetty, Undertow, Servlet 3.1+ containers, a choice of programming models&#8201;&#8212;&#8201;annotated controllers and functional web endpoints, and a choice of reactive libraries&#8201;&#8212;&#8201;Reactor, RxJava, or other.</p>
</div>
<div class="paragraph">
<p>If you are interested in a lightweight, functional web framework for use with Java 8 lambdas
or Kotlin then use the Spring WebFlux functional web endpoints. That can also be a good choice
for smaller applications or microservices with less complex requirements that can benefit
from greater transparency and control.</p>
</div>
<div class="paragraph">
<p>In a microservice architecture you can have a mix of applications with either Spring MVC
or Spring WebFlux controllers, or with Spring WebFlux functional endpoints. Having support
for the same annotation-based programming model in both frameworks makes it easier to
re-use knowledge while also selecting the right tool for the right job.</p>
</div>
<div class="paragraph">
<p>A simple way to evaluate an application is to check its dependencies. If you have blocking
persistence APIs (JPA, JDBC), or networking APIs to use, then Spring MVC is the best choice
for common architectures at least. It is technically feasible with both Reactor and
RxJava to perform blocking calls on a separate thread but you wouldn&#8217;t be making the
most of a non-blocking web stack.</p>
</div>
<div class="paragraph">
<p>If you have a Spring MVC application with calls to remote services, try the reactive <code>WebClient</code>.
You can return reactive types (Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a>)
directly from Spring MVC controller methods. The greater the latency per call, or the
interdependency among calls, the more dramatic the benefits. Spring MVC controllers
can call other reactive components too.</p>
</div>
<div class="paragraph">
<p>If you have a large team, keep in mind the steep learning curve in the shift to non-blocking,
functional, and declarative programming. A practical way to start without a full switch
is to use the reactive <code>WebClient</code>. Beyond that start small and measure the benefits.
We expect that for a wide range of applications the shift is unnecessary.</p>
</div>
<div class="paragraph">
<p>If you are unsure what benefits to look for, start by learning about how non-blocking I/O
works (e.g. concurrency on single-threaded Node.js is not an oxymoron) and its effects.
The tag line is "scale with less hardware" but that effect is not guaranteed, not without
some network I/O that can be slow or unpredictable. This Netflix
<a href="https://medium.com/netflix-techblog/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c">blog post</a>
is a good resource.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-server-choice"><a class="anchor" href="#webflux-server-choice"></a>1.1.6. Choosing a server</h4>
<div class="paragraph">
<p>Spring WebFlux is supported on Netty, Undertow, Tomcat, Jetty, and Servlet 3.1+ containers.
Each server is adapted to a common Reactive Streams API. The Spring WebFlux programming
models are built on that common API.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Common question: how can Tomcat and Jetty be used in both stacks?</strong><br>
Tomcat and Jetty are non-blocking at their core. It&#8217;s the Servlet API that adds a
blocking facade. Starting in version 3.1 the Servlet API adds a choice for non-blocking I/O.
However its use requires care to avoid other synchronous and blocking parts. For this
reason Spring&#8217;s reactive web stack has a low-level Servlet adapter to bridge to Reactive
Streams but the Servlet API is otherwise not exposed for direct use.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot 2 uses Netty by default with WebFlux because Netty is more widely used in the
async, non-blocking space and also provides both client and server that can share resources.
By comparison Servlet 3.1 non-blocking I/O hasn&#8217;t seen much use because the bar to use it
is so high. Spring WebFlux opens one practical path to adoption.</p>
</div>
<div class="paragraph">
<p>The default server choice in Spring Boot is mainly about the out-of-the-box experience.
Applications can still choose any of the other supported servers which are also highly
optimized for performance, fully non-blocking, and adapted to Reactive Streams back
pressure. In Spring Boot it is trivial to make the switch.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-performance"><a class="anchor" href="#webflux-performance"></a>1.1.7. Performance vs scale</h4>
<div class="paragraph">
<p>Performance has many characteristics and meanings. Reactive and non-blocking generally
do not make applications run faster. They can, in some cases, for example if using the
<code>WebClient</code> to execute remote calls in parallel. On the whole it requires more work to do
things the non-blocking way and that can increase slightly the required processing time.</p>
</div>
<div class="paragraph">
<p>The key expected benefit of reactive and non-blocking is the ability to scale with a small,
fixed number of threads and less memory. That makes applications more resilient under load
because they scale in a more predictable way. In order to observe those benefits however you
need to have some latency including a mix of slow and unpredictable network I/O.
That&#8217;s where the reactive stack begins to show its strengths and the differences can be
dramatic.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-reactive-spring-web"><a class="anchor" href="#webflux-reactive-spring-web"></a>1.2. Reactive Spring Web</h3>
<div class="paragraph">
<p>The <code>spring-web</code> module provides low level infrastructure and HTTP abstractions&#8201;&#8212;&#8201;client
and server, to build reactive web applications. All public APIs are build around Reactive
Streams with Reactor as a backing implementation.</p>
</div>
<div class="paragraph">
<p>Server support is organized in two layers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-httphandler">HttpHandler</a> and server adapters&#8201;&#8212;&#8201;the most basic, common API
for HTTP request handling with Reactive Streams back pressure.</p>
</li>
<li>
<p><a href="#webflux-web-handler-api">WebHandler API</a>&#8201;&#8212;&#8201;slightly higher level but still general
purpose server web API with filter chain style processing.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="webflux-httphandler"><a class="anchor" href="#webflux-httphandler"></a>1.2.1. HttpHandler</h4>
<div class="paragraph">
<p>Every HTTP server has some API for HTTP request handling.
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html">HttpHandler</a>
is a simple contract with one method to handle a request and response.
It is intentionally minimal. Its main purpose is to provide a common, Reactive Streams
based API for HTTP request handling over different servers.</p>
</div>
<div class="paragraph">
<p>The <code>spring-web</code> module contains adapters for every supported server. The table below shows
the server APIs are used and where Reactive Streams support comes from:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Server name</th>
<th class="tableblock halign-left valign-top">Server API used</th>
<th class="tableblock halign-left valign-top">Reactive Streams support</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/reactor/reactor-netty">Reactor Netty</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Undertow to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 non-blocking I/O; Jetty API to write ByteBuffers vs byte[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 non-blocking I/O</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Here are required dependencies,
<a href="https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework">supported versions</a>,
and code snippets for each server:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Server name</th>
<th class="tableblock halign-left valign-top">Group id</th>
<th class="tableblock halign-left valign-top">Artifact name</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactor Netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.projectreactor.ipc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor-netty</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">undertow-core</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.tomcat.embed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tomcat-embed-core</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.eclipse.jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">jetty-server, jetty-servlet</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Reactor Netty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = <span class="keyword">new</span> ReactorHttpHandlerAdapter(handler);
HttpServer.create(host, port).newHandler(adapter).block();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Undertow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler handler = ...
UndertowHttpHandlerAdapter adapter = <span class="keyword">new</span> UndertowHttpHandlerAdapter(handler);
Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tomcat:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler handler = ...
Servlet servlet = <span class="keyword">new</span> TomcatHttpHandlerAdapter(handler);

Tomcat server = <span class="keyword">new</span> Tomcat();
<span class="predefined-type">File</span> base = <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.io.tmpdir</span><span class="delimiter">&quot;</span></span>));
<span class="predefined-type">Context</span> rootContext = server.addContext(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>, base.getAbsolutePath());
Tomcat.addServlet(rootContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>, servlet);
rootContext.addServletMappingDecoded(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>);
server.setHost(host);
server.setPort(port);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler handler = ...
Servlet servlet = <span class="keyword">new</span> JettyHttpHandlerAdapter(handler);

Server server = <span class="keyword">new</span> Server();
ServletContextHandler contextHandler = <span class="keyword">new</span> ServletContextHandler(server, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>);
contextHandler.addServlet(<span class="keyword">new</span> ServletHolder(servlet), <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>);
contextHandler.start();

ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
connector.setHost(host);
connector.setPort(port);
server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To deploy as a WAR to a Servlet 3.1+ container, wrap <code>HttpHandler</code> with
<code>ServletHttpHandlerAdapter</code> and register that as a <code>Servlet</code>.
This can be automated through the use of
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html">AbstractReactiveWebInitializer</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-web-handler-api"><a class="anchor" href="#webflux-web-handler-api"></a>1.2.2. WebHandler API</h4>
<div class="paragraph">
<p><code>HttpHandler</code> is the basis for running on different servers. On that base the WebHandler
API provides a slightly higher level processing chain of
exception handlers
(<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/server/WebExceptionHandler.html">WebExceptionHandler</a>), filters
(<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/server/WebFilter.html">WebFilter</a>), and a target handler
(<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/server/WebHandler.html">WebHandler</a>).</p>
</div>
<div class="paragraph">
<p>All components work on <code>ServerWebExchange</code>&#8201;&#8212;&#8201;a container for the HTTP request and
response that also adds request attributes, session attributes, access to form data,
multipart data, and more.</p>
</div>
<div class="paragraph">
<p>The processing chain can be put together with <code>WebHttpHandlerBuilder</code> which builds an
<code>HttpHandler</code> that in turn can be run with a <a href="#webflux-httphandler">server adapter</a>.
To use the builder either add components individually or point to an <code>ApplicationContext</code>
to have the following detected:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 37.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean name</th>
<th class="tableblock halign-left valign-top">Bean type</th>
<th class="tableblock halign-left valign-top">Count</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">"webHandler"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WebHandler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target handler after filters</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WebFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Filters</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WebExceptionHandler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exception handlers after filter chain</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">"webSessionManager"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WebSessionManager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom session manager; <code>DefaultWebSessionManager</code> by default</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">"serverCodecConfigurer"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ServerCodecConfigurer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom form and multipart data decoders; <code>ServerCodecConfigurer.create()</code> by default</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">"localeContextResolver"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LocaleContextResolver</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom resolver for <code>LocaleContext</code>; <code>AcceptHeaderLocaleContextResolver</code> by default</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-codecs"><a class="anchor" href="#webflux-codecs"></a>1.2.3. Codecs</h4>
<div class="paragraph">
<p>The <code>spring-web</code> module provides
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageReader.html">HttpMessageReader</a> and
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html">HttpMessageWriter</a>
for encoding and decoding the HTTP request and response body with Reactive Streams.
It builds on lower level contracts from <code>spring-core</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html">DataBuffer</a>&#8201;&#8212;&#8201;abstraction for
byte buffers&#8201;&#8212;&#8201;e.g. Netty <code>ByteBuf</code>, <code>java.nio.ByteBuffer</code>, see
<a href="core.html#databuffers">Data Buffers and Codecs</a>.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/core/codec/Encoder.html">Encoder</a>&#8201;&#8212;&#8201;serialize a stream of Objects
to a stream of data buffers</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/core/codec/Decoder.html">Decoder</a>&#8201;&#8212;&#8201;deserialize a stream of data
buffers into a stream of Objects</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Basic <code>Encoder</code> and <code>Decoder</code> implementations exist in <code>spring-core</code> but <code>spring-web</code> adds
more for JSON, XML, and other formats. You can wrap any <code>Encoder</code> and <code>Decoder</code> as a reader
or writer with <code>EncoderHttpMessageWriter</code> and <code>DecoderHttpMessageReader</code>. There are some
additional, web-only reader and writer implementations for server-sent events, form data,
and more.</p>
</div>
<div class="paragraph">
<p>Finally, <code>ClientCodecConfigurer</code> and <code>ServerCodecConfigurer</code> can be used to initialize
a list of readers and writers. They include support for classpath detection and a
of defaults along with the ability to override or replace those defaults.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-dispatcher-handler"><a class="anchor" href="#webflux-dispatcher-handler"></a>1.3. DispatcherHandler</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux, like Spring MVC, is designed around the front controller pattern where a
central <code>WebHandler</code>, the <code>DispatcherHandler</code>, provides a shared algorithm for request
processing while actual work is performed by configurable, delegate components.
This model is flexible and supports diverse workflows.</p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code> discovers the delegate components it needs from Spring configuration.
It is also designed to be a Spring bean itself and implements <code>ApplicationContextAware</code>
for access to the context it runs in. If <code>DispatcherHandler</code> is declared with the bean
name "webHandler" it is in turn discovered by
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html">WebHttpHandlerBuilder</a>
which puts together a request processing chain as described in
<a href="#webflux-web-handler-api">WebHandler API</a>.</p>
</div>
<div class="paragraph">
<p>Spring configuration in a WebFlux application typically contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DispatcherHandler</code> with the bean name "webHandler"</p>
</li>
<li>
<p><code>WebFilter</code> and <code>WebExceptionHandler</code> beans</p>
</li>
<li>
<p><a href="#webflux-special-bean-types">DispatcherHandler special beans</a></p>
</li>
<li>
<p>Others</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The configuration is given to <code>WebHttpHandlerBuilder</code> to build the processing chain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = ...
HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting <code>HttpHandler</code> is ready for use with a
<a href="#webflux-httphandler">server adapter</a>.</p>
</div>
<div class="sect3">
<h4 id="webflux-special-bean-types"><a class="anchor" href="#webflux-special-bean-types"></a>1.3.1. Special bean types</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-special-bean-types">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>DispatcherHandler</code> delegates to special beans to process requests and render the
appropriate responses. By "special beans" we mean Spring-managed Object instances that
implement one of the framework contracts listed in the table below.
Spring WebFlux provides built-in implementations of these contracts but you can also
customize, extend, or replace them.</p>
</div>
<table id="webflux-special-beans-table" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean type</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HandlerMapping</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map a request to a handler. The mapping is based on some criteria the details of
  which vary by <code>HandlerMapping</code> implementation&#8201;&#8212;&#8201;annotated controllers, simple
  URL pattern mappings, etc.</p>
<p class="tableblock">  The main <code>HandlerMapping</code> implementations are <code>RequestMappingHandlerMapping</code> based on
  <code>@RequestMapping</code> annotated methods, <code>RouterFunctionMapping</code> based on functional
  endpoint routes, and <code>SimpleUrlHandlerMapping</code> based on explicit registrations of URI
  path patterns to handlers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HandlerAdapter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Help the <code>DispatcherHandler</code> to invoke a handler mapped to a request regardless of
  how the handler is actually invoked. For example invoking an annotated controller
  requires resolving annotations. The main purpose of a <code>HandlerAdapter</code> is to shield the
  <code>DispatcherHandler</code> from such details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HandlerResultHandler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process the result from the handler invocation and finalize the response.</p>
<p class="tableblock">  The built-in <code>HandlerResultHandler</code> implementations are <code>ResponseEntityResultHandler</code>
  supporting <code>ResponseEntity</code> return values, <code>ResponseBodyResultHandler</code>
  supporting <code>@ResponseBody</code> methods, <code>ServerResponseResultHandler</code>
  supporting the <code>ServerResponse</code> returned from functional endpoints, and
  <code>ViewResolutionResultHandler</code> supporting rendering with a view and a model.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-framework-config"><a class="anchor" href="#webflux-framework-config"></a>1.3.2. Framework Config</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-config">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>DispatcherHandler</code> detects the special beans it needs in the <code>ApplicationContext</code>.
Applications can declare the special beans they wish to have. However most applications
will find a better starting point in the WebFlux Java config which provide a higher level
configuration API that in turn make the necessary bean declarations.
See <a href="#webflux-config">WebFlux Java Config</a> for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-dispatcher-handler-sequence"><a class="anchor" href="#webflux-dispatcher-handler-sequence"></a>1.3.3. Processing</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-sequence">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>DispatcherHandler</code> processes requests as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each <code>HandlerMapping</code> is asked to find a matching handler and the first match is used.</p>
</li>
<li>
<p>If a handler is found, it is executed through an appropriate <code>HandlerAdapter</code> which
exposes the return value from the execution as <code>HandlerResult</code>.</p>
</li>
<li>
<p>The <code>HandlerResult</code> is given to an appropriate <code>HandlerResultHandler</code> to complete
processing by writing to the response directly or using a view to render.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-controller"><a class="anchor" href="#webflux-controller"></a>1.4. Annotated Controllers</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-controller">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux provides an annotation-based programming model where <code>@Controller</code> and
<code>@RestController</code> components use annotations to express request mappings, request input,
exception handling, and more. Annotated controllers have flexible method signatures and
do not have to extend base classes nor implement specific interfaces.</p>
</div>
<div class="paragraph">
<p>Here is a basic example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">HelloController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/hello</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="predefined-type">String</span> handle() {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello WebFlux</span><span class="delimiter">&quot;</span></span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example the methods returns a String to be written to the response body.</p>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller"><a class="anchor" href="#webflux-ann-controller"></a>1.4.1. @Controller</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-controller">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can define controller beans using a standard Spring bean definition.
The <code>@Controller</code> stereotype allows for auto-detection, aligned with Spring general support
for detecting <code>@Component</code> classes in the classpath and auto-registering bean definitions
for them. It also acts as a stereotype for the annotated class, indicating its role as
a web component.</p>
</div>
<div class="paragraph">
<p>To enable auto-detection of such <code>@Controller</code> beans, you can add component scanning to
your Java configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.web</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> {

    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@RestController</code> is a composed annotation that is itself annotated with
<code>@Controller</code> and <code>@ResponseBody</code> indicating a controller whose every method inherits the type-level
<code>@ResponseBody</code> annotation and therefore writes to the response body (vs model-and-vew
rendering).</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping"><a class="anchor" href="#webflux-ann-requestmapping"></a>1.4.2. Request Mapping</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>@RequestMapping</code> annotation is used to map requests to controllers methods. It has
various attributes to match by URL, HTTP method, request parameters, headers, and media
types. It can be used at the class-level to express shared mappings or at the method level
to narrow down to a specific endpoint mapping.</p>
</div>
<div class="paragraph">
<p>There are also HTTP method specific shortcut variants of <code>@RequestMapping</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The shortcut variants are
<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model#composed-annotations">composed annotations</a>&#8201;&#8212;&#8201;themselves annotated with <code>@RequestMapping</code>. They are commonly used at the method level.
At the class level an <code>@RequestMapping</code> is more useful for expressing shared mappings.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">PersonController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Person getPerson(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }

    <span class="annotation">@PostMapping</span>
    <span class="annotation">@ResponseStatus</span>(HttpStatus.CREATED)
    <span class="directive">public</span> <span class="type">void</span> add(<span class="annotation">@RequestBody</span> Person person) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-uri-templates"><a class="anchor" href="#webflux-ann-requestmapping-uri-templates"></a>URI Patterns</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-uri-templates">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can map requests using glob patterns and wildcards:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>?</code> matches one character</p>
</li>
<li>
<p><code>*</code> matches zero or more characters within a path segment</p>
</li>
<li>
<p><code>**</code> match zero or more path segments</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also declare URI variables and access their values with <code>@PathVariable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}/pets/{petId}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> Pet findPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> ownerId, <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> petId) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI variables can be declared at the class and method level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">OwnerController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/pets/{petId}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Pet findPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> ownerId, <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> petId) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI variables are automatically converted to the appropriate type or`TypeMismatchException`
is raised. Simple types&#8201;&#8212;&#8201;<code>int</code>, <code>long</code>, <code>Date</code>, are supported by default and you can
register support for any other data type.</p>
</div>
<div class="paragraph">
<p>URI variables can be named explicitly&#8201;&#8212;&#8201;e.g. <code>@PathVariable("customId")</code>, but you can
leave that detail out if the names are the same and your code is compiled with debugging
information or with the <code>-parameters</code> compiler flag on Java 8.</p>
</div>
<div class="paragraph">
<p>The syntax <code>{*varName}</code> declares a URI variable that matches zero or more remaining
path segments. For example <code>/resources/{*path}</code> matches all files <code>/resources/</code> and the
<code>"path"</code> variable captures the complete relative path.</p>
</div>
<div class="paragraph">
<p>The syntax <code>{varName:regex}</code> declares a URI variable with a regular expressions with the
syntax <code>{varName:regex}</code>&#8201;&#8212;&#8201;e.g. given URL <code>"/spring-web-3.0.5 .jar"</code>, the below method
extracts the name, version, and file extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{name:[a-z-]+}-{version:</span><span class="char">\\</span><span class="content">d</span><span class="char">\\</span><span class="content">.</span><span class="char">\\</span><span class="content">d</span><span class="char">\\</span><span class="content">.</span><span class="char">\\</span><span class="content">d}{ext:</span><span class="char">\\</span><span class="content">.[a-z]+}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> handle(<span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> version, <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> ext) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI path patterns can also have embedded <code>${&#8230;&#8203;}</code> placeholders that are resolved on startup
 via <code>PropertyPlaceHolderConfigurer</code> against local, system, environment, and other property
sources. This can be used for example to parameterize a base URL based on some external
configuration.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring WebFlux uses <code>PathPattern</code> and the <code>PathPatternParser</code> for URI path matching support
both of which are located in <code>spring-web</code> and expressly designed for use with HTTP URL
paths in web applications where a large number of URI path patterns are matched at runtime.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring WebFlux does not support suffix pattern matching&#8201;&#8212;&#8201;unlike Spring MVC, where a
mapping such as <code>/person</code> also matches to <code>/person.*</code>. For URL based content
negotiation, if needed, we recommend using a query parameter, which is simpler, more
explicit, and less vulnerable to URL path based exploits.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-pattern-comparison"><a class="anchor" href="#webflux-ann-requestmapping-pattern-comparison"></a>Pattern Comparison</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-pattern-comparison">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>When multiple patterns match a URL, they must be compared to find the best match. This is done
with <code>PathPattern.SPECIFICITY_COMPARATOR</code> which looks for patterns that more specific.</p>
</div>
<div class="paragraph">
<p>For every pattern, a score is computed based the number of URI variables and wildcards
where a URI variable scores lower than a wildcard. A pattern with a lower total score
wins. If two patterns have the same score, then the longer is chosen.</p>
</div>
<div class="paragraph">
<p>Catch-all patterns, e.g. <code>**</code>, <code>{*varName}</code>, are excluded from the scoring and are always
sorted last instead. If two patterns are both catch-all, the longer is chosen.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-consumes"><a class="anchor" href="#webflux-ann-requestmapping-consumes"></a>Consumable Media Types</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-consumes">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can narrow the request mapping based on the <code>Content-Type</code> of the request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(path = <span class="string"><span class="delimiter">&quot;</span><span class="content">/pets</span><span class="delimiter">&quot;</span></span>, <strong>consumes = <span class="string"><span class="delimiter">&quot;</span><span class="content">application/json</span><span class="delimiter">&quot;</span></span></strong>)
<span class="directive">public</span> <span class="type">void</span> addPet(<span class="annotation">@RequestBody</span> Pet pet) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The consumes attribute also supports negation expressions&#8201;&#8212;&#8201;e.g. <code>!text/plain</code> means any
content type other than "text/plain".</p>
</div>
<div class="paragraph">
<p>You can declare a shared consumes attribute at the class level. Unlike most other request
mapping attributes however when used at the class level, a method-level consumes attribute
will overrides rather than extend the class level declaration.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>MediaType</code> provides constants for commonly used media types&#8201;&#8212;&#8201;e.g.
<code>APPLICATION_JSON_VALUE</code>, <code>APPLICATION_JSON_UTF8_VALUE</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-produces"><a class="anchor" href="#webflux-ann-requestmapping-produces"></a>Producible Media Types</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-produces">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can narrow the request mapping based on the <code>Accept</code> request header and the list of
content types that a controller method produces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(path = <span class="string"><span class="delimiter">&quot;</span><span class="content">/pets/{petId}</span><span class="delimiter">&quot;</span></span>, <strong>produces = <span class="string"><span class="delimiter">&quot;</span><span class="content">application/json;charset=UTF-8</span><span class="delimiter">&quot;</span></span></strong>)
<span class="annotation">@ResponseBody</span>
<span class="directive">public</span> Pet getPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The media type can specify a character set. Negated expressions are supported&#8201;&#8212;&#8201;e.g.
<code>!text/plain</code> means any content type other than "text/plain".</p>
</div>
<div class="paragraph">
<p>You can declare a shared produces attribute at the class level. Unlike most other request
mapping attributes however when used at the class level, a method-level produces attribute
will overrides rather than extend the class level declaration.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>MediaType</code> provides constants for commonly used media types&#8201;&#8212;&#8201;e.g.
<code>APPLICATION_JSON_VALUE</code>, <code>APPLICATION_JSON_UTF8_VALUE</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-params-and-headers"><a class="anchor" href="#webflux-ann-requestmapping-params-and-headers"></a>Parameters and Headers</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-params-and-headers">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can narrow request mappings based on query parameter conditions. You can test for the
presence of a query parameter (<code>"myParam"</code>), for the absence (<code>"!myParam"</code>), or for a
specific value (<code>"myParam=myValue"</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(path = <span class="string"><span class="delimiter">&quot;</span><span class="content">/pets/{petId}</span><span class="delimiter">&quot;</span></span>, <strong>params = <span class="string"><span class="delimiter">&quot;</span><span class="content">myParam=myValue</span><span class="delimiter">&quot;</span></span></strong>)
<span class="directive">public</span> <span class="type">void</span> findPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the same with request header conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(path = <span class="string"><span class="delimiter">&quot;</span><span class="content">/pets</span><span class="delimiter">&quot;</span></span>, <strong>headers = <span class="string"><span class="delimiter">&quot;</span><span class="content">myHeader=myValue</span><span class="delimiter">&quot;</span></span></strong>)
<span class="directive">public</span> <span class="type">void</span> findPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-head-options"><a class="anchor" href="#webflux-ann-requestmapping-head-options"></a>HTTP HEAD, OPTIONS</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-head-options">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code>&#8201;&#8212;&#8201;and also <code>@RequestMapping(method=HttpMethod.GET)</code>, support HTTP HEAD
transparently for request mapping purposes. Controller methods don&#8217;t need to change.
A response wrapper, applied in the <code>HttpHandler</code> server adapter, ensures a <code>"Content-Length"</code>
header is set to the number of bytes written and without actually writing to the response.</p>
</div>
<div class="paragraph">
<p>By default HTTP OPTIONS is handled by setting the "Allow" response header to the list of HTTP
methods listed in all <code>@RequestMapping</code> methods with matching URL patterns.</p>
</div>
<div class="paragraph">
<p>For a <code>@RequestMapping</code> without HTTP method declarations, the "Allow" header is set to
<code>"GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS"</code>. Controller methods should always declare the
supported HTTP methods for example by using the HTTP method specific variants&#8201;&#8212;&#8201;<code>@GetMapping</code>, <code>@PostMapping</code>, etc.</p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> method can be explicitly mapped to HTTP HEAD and HTTP OPTIONS, but that
is not necessary in the common case.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-methods"><a class="anchor" href="#webflux-ann-methods"></a>1.4.3. Handler methods</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-methods">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> handler methods have a flexible signature and can choose from a range of
supported controller method arguments and return values.</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-arguments"><a class="anchor" href="#webflux-ann-arguments"></a>Method arguments</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-arguments">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The table below shows supported controller method arguments.</p>
</div>
<div class="paragraph">
<p>Reactive types (Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a>) are
supported on arguments that require blocking I/O, e.g. reading the request body, to
be resolved. This is marked in the description column. Reactive types are not expected
on arguments that don&#8217;t require blocking.</p>
</div>
<div class="paragraph">
<p>JDK 1.8&#8217;s <code>java.util.Optional</code> is supported as a method argument in combination with
annotations that have a <code>required</code> attribute&#8201;&#8212;&#8201;e.g. <code>@RequestParam</code>, <code>@RequestHeader</code>,
etc, and is equivalent to <code>required=false</code>.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method argument</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerWebExchange</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the full <code>ServerWebExchange</code>&#8201;&#8212;&#8201;container for the HTTP request and response,
request and session attributes, <code>checkNotModified</code> methods, and others.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerHttpRequest</code>, <code>ServerHttpResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the HTTP request or response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the session; this does not forcing the start of a new session unless attributes
are added. Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Currently authenticated user; possibly a specific <code>Principal</code> implementation class if known.
Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.http.HttpMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The HTTP method of the request.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The current request locale, determined by the most specific <code>LocaleResolver</code> available, in
 effect, the configured <code>LocaleResolver</code>/<code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 6+: <code>java.util.TimeZone</code><br>
Java 8+: <code>java.time.ZoneId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@PathVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to URI template variables.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@MatrixVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to name-value pairs in URI path segments.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestParam</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to Servlet request parameters. Parameter values are converted to the declared
method argument type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers. Header values are converted to the declared method argument
type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the HTTP request body. Body content is converted to the declared method
argument type using <code>HttpMessageReader</code>'s. Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers and body. The body is converted with <code>HttpMessageReader</code>'s.
Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestPart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to a part in  a "multipart/form-data" request. Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access and updates of the implicit model that is exposed to the web view.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command or form object (with optional <code>@ModelAttribute</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command object whose properties to bind to request parameters&#8201;&#8212;&#8201;via setters or directly to
fields, with customizable type conversion, depending on <code>@InitBinder</code> methods and/or the
HandlerAdapter configuration (see the <code>webBindingInitializer</code> property on
<code>RequestMappingHandlerAdapter</code>).</p>
<p class="tableblock">Command objects along with their validation results are exposed as model attributes, by
default using the command class name - e.g. model attribute "orderAddress" for a command
object of type "some.package.OrderAddress". <code>@ModelAttribute</code> can be used to customize the
model attribute name.</p>
<p class="tableblock">Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Errors</code>, <code>BindingResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Validation results for the command/form object data binding; this argument must be
declared immediately after the command/form object in the controller method signature.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionStatus</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For marking form processing complete which triggers cleanup of session attributes
declared through a class-level <code>@SessionAttributes</code> annotation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UriComponentsBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For preparing a URL relative to the current request&#8217;s host, port, scheme, context path, and
the literal  part of the servlet mapping also taking into account <code>Forwarded</code> and
<code>X-Forwarded-*</code> headers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to any session attribute; in contrast to model attributes stored in the session
as a result of a class-level <code>@SessionAttributes</code> declaration.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request attributes.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-ann-return-types"><a class="anchor" href="#webflux-ann-return-types"></a>Return values</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-return-types">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The table below shows supported controller method return values. Reactive types&#8201;&#8212;&#8201;Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a> are supported for all return
values.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method return value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value is encoded through <code>HttpMessageWriter</code>s and written to the response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value specifies the full response including HTTP headers and body be encoded
through <code>HttpMessageWriter</code>s and written to the response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For returning a response with headers and no body.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A view name to be resolved with <code>ViewResolver</code>'s and used together with the implicit
model&#8201;&#8212;&#8201;determined through command objects and <code>@ModelAttribute</code> methods. The handler
method may also programmatically enrich the model by declaring a <code>Model</code> argument (see
above).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>View</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>View</code> instance to use for rendering together with the implicit model&#8201;&#8212;&#8201;determined
through command objects and <code>@ModelAttribute</code> methods. The handler method may also
programmatically enrich the model by declaring a <code>Model</code> argument (see above).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attributes to be added to the implicit model with the view name implicitly determined
from the request path.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Rendering</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An API for model and view rendering scenarios.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A method with a <code>void</code>, possibly async (e.g. <code>Mono&lt;Void&gt;</code>), return type (or a <code>null</code> return
value) is considered to have fully handled the response if it also has a <code>ServerHttpResponse</code>,
or a <code>ServerWebExchange</code> argument, or an <code>@ResponseStatus</code> annotation. The same is true also
if the controller has made a positive ETag or lastModified timestamp check.</p>
<p class="tableblock">If none of the above is true, a <code>void</code> return type may also indicate "no response body" for
REST controllers, or default view name selection for HTML controllers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux&lt;ServerSentEvent&gt;</code>, <code>Observable&lt;ServerSentEvent&gt;</code>, or other reactive type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Emit server-sent events; the <code>SeverSentEvent</code> wrapper can be omitted when only data needs
to be written (however <code>text/event-stream</code> must be requested or declared in the mapping
through the produces attribute).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other return type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A single model attribute to be added to the implicit model with the view name implicitly
determined through a <code>RequestToViewNameTranslator</code>; the attribute name may be specified
through a method-level <code>@ModelAttribute</code> or otherwise a name is selected based on the
class name of the return type.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-fn"><a class="anchor" href="#webflux-fn"></a>1.5. Functional Endpoints</h3>
<div class="paragraph">
<p>Spring WebFlux provides a lightweight, functional programming model where functions
are used to route and handle requests and where contracts are designed for immutability.
It is an alternative to the annotated-based programming model but runs on the same
<a href="#webflux-reactive-spring-web">Reactive Spring Web</a> foundation</p>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-functions"><a class="anchor" href="#webflux-fn-handler-functions"></a>1.5.1. HandlerFunction</h4>
<div class="paragraph">
<p>Incoming HTTP requests are handled by a <strong><code>HandlerFunction</code></strong>, which is essentially a function that
takes a <code>ServerRequest</code> and returns a <code>Mono&lt;ServerResponse&gt;</code>. The annotation counterpart to a
handler function is an <code>@RequestMapping</code> method.</p>
</div>
<div class="paragraph">
<p><code>ServerRequest</code> and <code>ServerResponse</code> are immutable interfaces that offer JDK-8 friendly access
to the underlying HTTP messages with <a href="http://www.reactive-streams.org">Reactive Streams</a>
non-blocking back pressure. The request exposes the body as Reactor <code>Flux</code> or <code>Mono</code>
types; the response accepts any Reactive Streams <code>Publisher</code> as body (see
<a href="#webflux-reactive-libraries">Reactive Libraries</a>).</p>
</div>
<div class="paragraph">
<p><code>ServerRequest</code> gives access to various HTTP request elements:
the method, URI, query parameters, and&#8201;&#8212;&#8201;through the separate <code>ServerRequest.Headers</code> interface&#8201;&#8212;&#8201;the headers. Access to the body is provided through the <code>body</code> methods. For instance, this is
how to extract the request body into a <code>Mono&lt;String&gt;</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Mono&lt;String&gt; string = request.bodyToMono(String.class);</pre>
</div>
</div>
<div class="paragraph">
<p>And here is how to extract the body into a <code>Flux</code>, where <code>Person</code> is a class that can be
deserialised from the contents of the body (i.e. <code>Person</code> is supported by Jackson if the body
contains JSON, or JAXB if XML).</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Flux&lt;Person&gt; people = request.bodyToFlux(Person.class);</pre>
</div>
</div>
<div class="paragraph">
<p>The above&#8201;&#8212;&#8201;<code>bodyToMono</code> and <code>bodyToFlux</code>, are, in fact, convenience methods that use the
generic <code>ServerRequest.body(BodyExtractor)</code> method. <code>BodyExtractor</code> is
a functional strategy interface that allows you to write your own extraction logic, but common
<code>BodyExtractor</code> instances can be found in the <code>BodyExtractors</code> utility class. So, the above
examples can be replaced with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Mono&lt;String&gt; string = request.body(BodyExtractors.toMono(String.class);
Flux&lt;Person&gt; people = request.body(BodyExtractors.toFlux(Person.class);</pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, <code>ServerResponse</code> provides access to the HTTP response. Since it is immutable, you create
a <code>ServerResponse</code> with a builder. The builder allows you to set the response status, add response
headers, and provide a body. For instance, this is how to create a response with a 200 OK status,
a JSON content-type, and a body:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Mono&lt;Person&gt; person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);</pre>
</div>
</div>
<div class="paragraph">
<p>And here is how to build a response with a 201 CREATED status, a <code>"Location"</code> header, and
empty body:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>URI location = ...
ServerResponse.created(location).build();</pre>
</div>
</div>
<div class="paragraph">
<p>Putting these together allows us to create a <code>HandlerFunction</code>. For instance, here is an example
of a simple "Hello World" handler lambda, that returns a response with a 200 status and a body
based on a String:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HandlerFunction&lt;ServerResponse&gt; helloWorld =
  request -&gt; ServerResponse.ok().body(fromObject(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Writing handler functions as lambda&#8217;s, as we do above, is convenient, but perhaps lacks in
readability and becomes less maintainable when dealing with multiple functions. Therefore, it is
recommended to group related handler functions into a handler or controller class. For example,
here is a class that exposes a reactive <code>Person</code> repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http.MediaType.APPLICATION_JSON</span>;
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.BodyInserters.fromObject</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">PersonHandler</span> {

    <span class="directive">private</span> <span class="directive">final</span> PersonRepository repository;

    <span class="directive">public</span> PersonHandler(PersonRepository repository) {
        <span class="local-variable">this</span>.repository = repository;
    }

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) { <i class="conum" data-value="1"></i><b>(1)</b>
        Flux&lt;Person&gt; people = repository.allPeople();
        <span class="keyword">return</span> ServerResponse.ok().contentType(APPLICATION_JSON).body(people, Person.class);
    }

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) { <i class="conum" data-value="2"></i><b>(2)</b>
        Mono&lt;Person&gt; person = request.bodyToMono(Person.class);
        <span class="keyword">return</span> ServerResponse.ok().build(repository.savePerson(person));
    }

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) { <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="type">int</span> personId = <span class="predefined-type">Integer</span>.valueOf(request.pathVariable(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>));
        Mono&lt;ServerResponse&gt; notFound = ServerResponse.notFound().build();
        Mono&lt;Person&gt; personMono = <span class="local-variable">this</span>.repository.getPerson(personId);
        <span class="keyword">return</span> personMono
                .flatMap(person -&gt; ServerResponse.ok().contentType(APPLICATION_JSON).body(fromObject(person)))
                .switchIfEmpty(notFound);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>listPeople</code> is a handler function that returns all <code>Person</code> objects found in the repository as
JSON.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>createPerson</code> is a handler function that stores a new <code>Person</code> contained in the request body.
Note that <code>PersonRepository.savePerson(Person)</code> returns <code>Mono&lt;Void&gt;</code>: an empty Mono that emits
a completion signal when the person has been read from the request and stored. So we use the
<code>build(Publisher&lt;Void&gt;)</code> method to send a response when that completion signal is received, i.e.
when the <code>Person</code> has been saved.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>getPerson</code> is a handler function that returns a single person, identified via the path
variable <code>id</code>. We retrieve that <code>Person</code> via the repository, and create a JSON response if it is
found. If it is not found, we use <code>switchIfEmpty(Mono&lt;T&gt;)</code> to return a 404 Not Found response.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-router-functions"><a class="anchor" href="#webflux-fn-router-functions"></a>1.5.2. RouterFunction</h4>
<div class="paragraph">
<p>Incoming requests are routed to handler functions with a <strong><code>RouterFunction</code></strong>, which is a function
that takes a <code>ServerRequest</code>, and returns a <code>Mono&lt;HandlerFunction&gt;</code>. If a request matches a
particular route, a handler function is returned; otherwise it returns an empty <code>Mono</code>. The
<code>RouterFunction</code> has a similar purpose as the <code>@RequestMapping</code> annotation in <code>@Controller</code> classes.</p>
</div>
<div class="paragraph">
<p>Typically, you do not write router functions yourself, but rather use
<code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code> to
create one using a request predicate and handler function. If the predicate applies, the request is
routed to the given handler function; otherwise no routing is performed, resulting in a
404 Not Found response.
Though you can write your own <code>RequestPredicate</code>, you do not have to: the <code>RequestPredicates</code>
utility class offers commonly used predicates, such matching based on path, HTTP method,
content-type, etc.
Using <code>route</code>, we can route to our "Hello World" handler function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RouterFunction&lt;ServerResponse&gt; helloWorldRoute =
    RouterFunctions.route(RequestPredicates.path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/hello-world</span><span class="delimiter">&quot;</span></span>),
    request -&gt; Response.ok().body(fromObject(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two router functions can be composed into a new router function that routes to either handler
function: if the predicate of the first route does not match, the second is evaluated.
Composed router functions are evaluated in order, so it makes sense to put specific functions
before generic ones.
You can compose two router functions by calling <code>RouterFunction.and(RouterFunction)</code>, or by calling
<code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code>, which is a convenient combination
of <code>RouterFunction.and()</code> with <code>RouterFunctions.route()</code>.</p>
</div>
<div class="paragraph">
<p>Given the <code>PersonHandler</code> we showed above, we can now define a router function that routes to the
respective handler functions.
We use <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">method-references</a>
to refer to the handler functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http.MediaType.APPLICATION_JSON</span>;
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.server.RequestPredicates</span>.*;

PersonRepository repository = ...
PersonHandler handler = <span class="keyword">new</span> PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; personRoute =
    route(GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person/{id}</span><span class="delimiter">&quot;</span></span>).and(accept(APPLICATION_JSON)), handler::getPerson)
        .andRoute(GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>).and(accept(APPLICATION_JSON)), handler::listPeople)
        .andRoute(POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>).and(contentType(APPLICATION_JSON)), handler::createPerson);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Besides router functions, you can also compose request predicates, by calling
<code>RequestPredicate.and(RequestPredicate)</code> or <code>RequestPredicate.or(RequestPredicate)</code>.
These work as expected: for <code>and</code> the resulting predicate matches if <strong>both</strong> given predicates match;
<code>or</code> matches if <strong>either</strong> predicate does.
Most of the predicates found in <code>RequestPredicates</code> are compositions.
For instance, <code>RequestPredicates.GET(String)</code> is a composition of
<code>RequestPredicates.method(HttpMethod)</code> and <code>RequestPredicates.path(String)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-running"><a class="anchor" href="#webflux-fn-running"></a>1.5.3. Running a server</h4>
<div class="paragraph">
<p>How do you run a router function in an HTTP server? A simple option is to convert a
router function to an <code>HttpHandler</code> via <code>RouterFunctions.toHttpHandler(RouterFunction)</code>.
The <code>HttpHandler</code> can then be used with a number of servers adapters.
See <a href="#webflux-httphandler">HttpHandler</a> for server-specific
instructions.</p>
</div>
<div class="paragraph">
<p>it is also possible to run with a
<a href="#webflux-dispatcher-handler">DispatcherHandler</a> setup&#8201;&#8212;&#8201;side by side
with annotated controllers. The easiest way to do that is through the
<a href="#webflux-config">WebFlux Java Config</a> which creates the necessary configuration to
handle requests with router and handler functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-filter-function"><a class="anchor" href="#webflux-fn-handler-filter-function"></a>1.5.4. HandlerFilterFunction</h4>
<div class="paragraph">
<p>Routes mapped by a router function can be filtered by calling
<code>RouterFunction.filter(HandlerFilterFunction)</code>, where <code>HandlerFilterFunction</code> is essentially a
function that takes a <code>ServerRequest</code> and <code>HandlerFunction</code>, and returns a <code>ServerResponse</code>.
The handler function parameter represents the next element in the chain: this is typically the
<code>HandlerFunction</code> that is routed to, but can also be another <code>FilterFunction</code> if multiple filters
are applied.
With annotations, similar functionality can be achieved using <code>@ControllerAdvice</code> and/or a <code>ServletFilter</code>.
Let&#8217;s add a simple security filter to our route, assuming that we have a <code>SecurityManager</code> that
can determine whether a particular path is allowed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http.HttpStatus.UNAUTHORIZED</span>;

<span class="predefined-type">SecurityManager</span> securityManager = ...
RouterFunction&lt;ServerResponse&gt; route = ...

RouterFunction&lt;ServerResponse&gt; filteredRoute =
    route.filter(request, next) -&gt; {
        <span class="keyword">if</span> (securityManager.allowAccessTo(request.path())) {
            <span class="keyword">return</span> next.handle(request);
        }
        <span class="keyword">else</span> {
            <span class="keyword">return</span> ServerResponse.status(UNAUTHORIZED).build();
        }
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see in this example that invoking the <code>next.handle(ServerRequest)</code> is optional: we only
allow the handler function to be executed when access is allowed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>CORS support for functional endpoints is provided via a dedicated <a href="#webflux-cors-webfilter"><code>CorsWebFilter</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config"><a class="anchor" href="#webflux-config"></a>1.6. WebFlux Java Config</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The WebFlux Java config provides default configuration suitable for most applications along
with a configuration API to customize it. For more advanced customizations, not available in
the configuration API, see <a href="#webflux-config-advanced-java">Advanced config mode</a>.</p>
</div>
<div class="paragraph">
<p>You do not need to understand the underlying beans created by the Java config, but it&#8217;s
easy to seem them in <code>WebFluxConfigurationSupport</code>, and if you want to learn more, see
<a href="#webflux-special-bean-types">Special bean types</a>.</p>
</div>
<div class="sect3">
<h4 id="webflux-config-enable"><a class="anchor" href="#webflux-config-enable"></a>1.6.1. Enable WebFlux config</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-enable">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Use the <code>@EnableWebFlux</code> annotation in your Java config:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above registers a number of Spring WebFlux
<a href="#mvc-webflux-special-bean-types">infrastructure beans</a> also adapting to dependencies
available on the classpath&#8201;&#8212;&#8201;for JSON, XML, etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-customize"><a class="anchor" href="#webflux-config-customize"></a>1.6.2. WebFlux config API</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-customize">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>In your Java config implement the <code>WebFluxConfigurer</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="comment">// Implement configuration methods...</span>

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-conversion"><a class="anchor" href="#webflux-config-conversion"></a>1.6.3. Conversion, formatting</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-conversion">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>By default formatters for <code>Number</code> and <code>Date</code> types are installed, including support for
the <code>@NumberFormat</code> and <code>@DateTimeFormat</code> annotations. Full support for the Joda Time
formatting library is also installed if Joda Time is present on the classpath.</p>
</div>
<div class="paragraph">
<p>To register custom formatters and converters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addFormatters(FormatterRegistry registry) {
        <span class="comment">// ...</span>
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>See <a href="core.html#format-FormatterRegistrar-SPI">FormatterRegistrar SPI</a>
and the <code>FormattingConversionServiceFactoryBean</code> for more information on when to use FormatterRegistrars.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-validation"><a class="anchor" href="#webflux-config-validation"></a>1.6.4. Validation</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-validation">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>By default if <a href="core.html#validation-beanvalidation-overview">Bean Validation</a> is present
on the classpath&#8201;&#8212;&#8201;e.g. Hibernate Validator, the <code>LocalValidatorFactoryBean</code> is registered
as a global <a href="core.html#validator">Validator</a> for use with <code>@Valid</code> and <code>Validated</code> on
<code>@Controller</code> method arguments.</p>
</div>
<div class="paragraph">
<p>In your Java config, you can customize the global <code>Validator</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Validator</span> getValidator(); {
        <span class="comment">// ...</span>
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can also register <code>Validator</code>'s locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyController</span> {

    <span class="annotation">@InitBinder</span>
    <span class="directive">protected</span> <span class="type">void</span> initBinder(WebDataBinder binder) {
        binder.addValidators(<span class="keyword">new</span> FooValidator());
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you need to have a <code>LocalValidatorFactoryBean</code> injected somewhere, create a bean and
mark it with <code>@Primary</code> in order to avoid conflict with the one declared in the MVC config.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-content-negotiation"><a class="anchor" href="#webflux-config-content-negotiation"></a>1.6.5. Content type resolvers</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-content-negotiation">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can configure how Spring WebFlux determines the requested media types for
<code>@Controller</code>'s from the request. By default only the "Accept" header is checked but you
can also enable a query parameter based strategy.</p>
</div>
<div class="paragraph">
<p>To customize the requested content type resolution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-message-codecs"><a class="anchor" href="#webflux-config-message-codecs"></a>1.6.6. HTTP message codecs</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-message-converters">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>To customize how the request and response body are read and written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ServerCodecConfigurer</code> provides a set of default readers and writers. You can use it to add
more readers and writers, customize the default ones, or replace the default ones completely.</p>
</div>
<div class="paragraph">
<p>For Jackson JSON and XML, consider using the
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html">Jackson2ObjectMapperBuilder</a>
which customizes Jackson&#8217;s default properties with the following ones:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a> is disabled.</p>
</li>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a> is disabled.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It also automatically registers the following well-known modules if they are detected on the classpath:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk7">jackson-datatype-jdk7</a>: support for Java 7 types like <code>java.nio.file.Path</code>.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a>: support for Joda-Time types.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a>: support for Java 8 Date &amp; Time API types.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a>: support for other Java 8 types like <code>Optional</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-view-resolvers"><a class="anchor" href="#webflux-config-view-resolvers"></a>1.6.7. View resolvers</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-view-resolvers">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>To configure view resolution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureViewResolvers(ViewResolverRegistry registry) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that FreeMarker also requires configuration of the underlying view technology:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="comment">// ...</span>

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/templates</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> configurer;
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-static-resources"><a class="anchor" href="#webflux-config-static-resources"></a>1.6.8. Static resources</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-static-resources">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>This option provides a convenient way to serve static resources from a list of
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/core/io/Resource.html">Resource</a>-based locations.</p>
</div>
<div class="paragraph">
<p>In the example below, given a request that starts with <code>"/resources"</code>, the relative path is
used to find and serve static resources relative to <code>"/static"</code> on the classpath. Resources
will be served with a 1-year future expiration to ensure maximum use of the browser cache
and a reduction in HTTP requests made by the browser. The <code>Last-Modified</code> header is also
evaluated and if present a <code>304</code> status code is returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resources/**</span><span class="delimiter">&quot;</span></span>)
            .addResourceLocations(<span class="string"><span class="delimiter">&quot;</span><span class="content">/public</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/static/</span><span class="delimiter">&quot;</span></span>)
            .setCachePeriod(<span class="integer">31556926</span>);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resource handler also supports a chain of
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceResolver.html">ResourceResolver</a>'s and
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceTransformer.html">ResourceTransformer</a>'s.
which can be used to create a toolchain for working with optimized resources.</p>
</div>
<div class="paragraph">
<p>The <code>VersionResourceResolver</code> can be used for versioned resource URLs based on an MD5 hash
computed from the content, a fixed application version, or other. A
<code>ContentVersionStrategy</code> (MD5 hash) is a good choice with some notable exceptions such as
JavaScript resources used with a module loader.</p>
</div>
<div class="paragraph">
<p>For example in your Java config;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resources/**</span><span class="delimiter">&quot;</span></span>)
                .addResourceLocations(<span class="string"><span class="delimiter">&quot;</span><span class="content">/public/</span><span class="delimiter">&quot;</span></span>)
                .resourceChain(<span class="predefined-constant">true</span>)
                .addResolver(<span class="keyword">new</span> VersionResourceResolver().addContentVersionStrategy(<span class="string"><span class="delimiter">&quot;</span><span class="content">/**</span><span class="delimiter">&quot;</span></span>));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>ResourceUrlProvider</code> to rewrite URLs and apply the full chain of resolvers and
transformers&#8201;&#8212;&#8201;e.g. to insert versions. The WebFlux config provides a <code>ResourceUrlProvider</code>
so it can be injected into others.</p>
</div>
<div class="paragraph">
<p>Unlike Spring MVC at present in WebFlux there is no way to transparely rewrite static
resource URLs since the are no view technologies that can make use of a non-blocking chain
of resolvers and transformers (e.g. resources on Amazon S3). When serving only local
resources the workaround is to use <code>ResourceUrlProvider</code> directly (e.g. through a custom
tag) and block for 0 seconds.</p>
</div>
<div class="paragraph">
<p><a href="http://www.webjars.org/documentation">WebJars</a> is also supported via <code>WebJarsResourceResolver</code>
and automatically registered when <code>"org.webjars:webjars-locator"</code> is present on the
classpath. The resolver can re-write URLs to include the version of the jar and can also
match to incoming URLs without versions&#8201;&#8212;&#8201;e.g. <code>"/jquery/jquery.min.js"</code> to
<code>"/jquery/1.2.0/jquery.min.js"</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-path-matching"><a class="anchor" href="#webflux-config-path-matching"></a>1.6.9. Path Matching</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-path-matching">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux uses parsed representation of path patterns&#8201;&#8212;&#8201;i.e. <code>PathPattern</code>, and also
the incoming  request path&#8201;&#8212;&#8201;i.e. <code>RequestPath</code>, which eliminates the need to indicate
whether to decode the request path, or remove semicolon content, since <code>PathPattern</code>
can now access decoded path segment values and match safely.</p>
</div>
<div class="paragraph">
<p>Spring WebFlux also does not support suffix pattern matching so effectively there are only two
minor options to customize related to path matching&#8201;&#8212;&#8201;whether to match trailing slashes
(<code>true</code> by default) and whether the match is case-sensitive (<code>false</code>).</p>
</div>
<div class="paragraph">
<p>To customize those options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configurePathMatch(PathMatchConfigurer configurer) {
        <span class="comment">// ...</span>
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-advanced-java"><a class="anchor" href="#webflux-config-advanced-java"></a>1.6.10. Advanced config mode</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-advanced-java">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@EnableWebFlux</code> imports <code>DelegatingWebFluxConfiguration</code> that (1) provides default
Spring configuration for WebFlux applications and (2) detects and delegates to
<code>WebFluxConfigurer</code>'s to customize that configuration.</p>
</div>
<div class="paragraph">
<p>For advanced mode, remove <code>@EnableWebFlux</code> and extend directly from
<code>DelegatingWebFluxConfiguration</code> instead of implementing <code>WebFluxConfigurer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">extends</span> DelegatingWebFluxConfiguration {

    <span class="comment">// ...</span>

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can keep existing methods in <code>WebConfig</code> but you can now also override bean declarations
from the base class and you can still have any number of other <code>WebMvcConfigurer</code>'s on
the classpath.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-cors"><a class="anchor" href="#webflux-cors"></a>1.7. CORS</h3>
<div class="sect3">
<h4 id="introduction"><a class="anchor" href="#introduction"></a>1.7.1. Introduction</h4>
<div class="paragraph">
<p>For security reasons, browsers prohibit AJAX calls to resources residing outside the
current origin. For example, as you&#8217;re checking your bank account in one tab, you
could have the evil.com website open in another tab. The scripts from evil.com should not
be able to make AJAX requests to your bank API (e.g., withdrawing money from your account!)
using your credentials.</p>
</div>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross-origin resource sharing</a>
(CORS) is a <a href="http://www.w3.org/TR/cors/">W3C specification</a> implemented by
<a href="http://caniuse.com/#feat=cors">most browsers</a> that allows you to specify in a flexible
way what kind of cross domain requests are authorized, instead of using some less secured
and less powerful hacks like IFRAME or JSONP.</p>
</div>
<div class="paragraph">
<p>Spring WebFlux supports CORS out of the box. CORS requests, including preflight ones with an <code>OPTIONS</code> method,
are automatically dispatched to the various registered <code>HandlerMapping</code>s. They handle
CORS preflight requests and intercept CORS simple and actual requests thanks to a
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/cors/reactive/CorsProcessor.html">CorsProcessor</a>
implementation (<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/cors/reactive/DefaultCorsProcessor.java">DefaultCorsProcessor</a>
by default) in order to add the relevant CORS response headers (like <code>Access-Control-Allow-Origin</code>)
based on the CORS configuration you have provided.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Be aware that cookies are not allowed by default to avoid increasing the surface attack of
the web application (for example via exposing sensitive user-specific information like
CSRF tokens). Set <code>allowedCredentials</code> property to <code>true</code> in order to allow them.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-controller"><a class="anchor" href="#webflux-cors-controller"></a>1.7.2. @CrossOrigin</h4>
<div class="paragraph">
<p>You can add an
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>
annotation to your <code>@RequestMapping</code> annotated handler method in order to enable CORS on
it. By default <code>@CrossOrigin</code> allows all origins and the HTTP methods specified in the
<code>@RequestMapping</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/account</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AccountController</span> {

    <span class="annotation">@CrossOrigin</span>
    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;Account&gt; retrieve(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }

    <span class="annotation">@DeleteMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; remove(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to enable CORS for the whole controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CrossOrigin</span>(origins = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain2.com</span><span class="delimiter">&quot;</span></span>, maxAge = <span class="integer">3600</span>)
<span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/account</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AccountController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;Account&gt; retrieve(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }

    <span class="annotation">@DeleteMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; remove(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example CORS support is enabled for both the <code>retrieve()</code> and the <code>remove()</code>
handler methods, and you can also see how you can customize the CORS configuration using
<code>@CrossOrigin</code> attributes.</p>
</div>
<div class="paragraph">
<p>You can even use both controller-level and method-level CORS configurations; Spring will
then combine attributes from both annotations to create merged CORS configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CrossOrigin</span>(maxAge = <span class="integer">3600</span>)
<span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/account</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AccountController</span> {

    <span class="annotation">@CrossOrigin</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain2.com</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Account retrieve(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }

    <span class="annotation">@DeleteMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> remove(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-java-config"><a class="anchor" href="#webflux-cors-java-config"></a>1.7.3. Java Config</h4>
<div class="paragraph">
<p>In addition to fine-grained, annotation-based configuration you&#8217;ll probably want to
define some global CORS configuration as well. This is similar to using filters but can
be declared within Spring WebFlux and combined with fine-grained <code>@CrossOrigin</code> configuration.
By default all origins and <code>GET</code>, <code>HEAD</code>, and <code>POST</code> methods are allowed.</p>
</div>
<div class="paragraph">
<p>Enabling CORS for the whole application is as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addCorsMappings(CorsRegistry registry) {
        registry.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">/**</span><span class="delimiter">&quot;</span></span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can easily change any properties, as well as only apply this CORS configuration to a
specific path pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addCorsMappings(CorsRegistry registry) {
        registry.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">/api/**</span><span class="delimiter">&quot;</span></span>)
            .allowedOrigins(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain2.com</span><span class="delimiter">&quot;</span></span>)
            .allowedMethods(<span class="string"><span class="delimiter">&quot;</span><span class="content">PUT</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">DELETE</span><span class="delimiter">&quot;</span></span>)
            .allowedHeaders(<span class="string"><span class="delimiter">&quot;</span><span class="content">header1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">header2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">header3</span><span class="delimiter">&quot;</span></span>)
            .exposedHeaders(<span class="string"><span class="delimiter">&quot;</span><span class="content">header1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">header2</span><span class="delimiter">&quot;</span></span>)
            .allowCredentials(<span class="predefined-constant">true</span>).maxAge(<span class="integer">3600</span>);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-webfilter"><a class="anchor" href="#webflux-cors-webfilter"></a>1.7.4. CORS WebFilter</h4>
<div class="paragraph">
<p>You can apply CORS support through the built-in
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/cors/reactive/CorsWebFilter.html"><code>CorsWebFilter</code></a>, which is a
good fit with <a href="#webflux-fn">functional endpoints</a>.</p>
</div>
<div class="paragraph">
<p>To configure the filter, you can declare a <code>CorsWebFilter</code> bean and pass a
<code>CorsConfigurationSource</code> to its constructor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>
CorsWebFilter corsFilter() {
    CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();
    config.setAllowCredentials(<span class="predefined-constant">true</span>);
    config.addAllowedOrigin(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain1.com</span><span class="delimiter">&quot;</span></span>);
    config.addAllowedHeader(<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span>);
    config.addAllowedMethod(<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span>);

    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration(<span class="string"><span class="delimiter">&quot;</span><span class="content">/**</span><span class="delimiter">&quot;</span></span>, config);

    <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also easily permit all cross-origin requests for GET, HEAD, and POST requests by writing</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>
CorsWebFilter corsFilter() {
    <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(exchange -&gt; <span class="keyword">new</span> CorsConfiguration().applyPermitDefaultValues());
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-customizations"><a class="anchor" href="#webflux-cors-customizations"></a>1.7.5. Advanced Customization</h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html">CorsConfiguration</a>
allows you to specify how the CORS requests should be processed: allowed origins, headers, methods, etc.
It can be provided in various ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/reactive/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-"><code>AbstractHandlerMapping#setCorsConfigurations()</code></a>
allows to specify a <code>Map</code> with several <a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html">CorsConfiguration</a>
instances mapped to path patterns like <code>/api/**</code>.</p>
</li>
<li>
<p>Subclasses can provide their own <code>CorsConfiguration</code> by overriding the
<code>AbstractHandlerMapping#getCorsConfiguration(Object, ServerWebExchange)</code> method.</p>
</li>
<li>
<p>Handlers can implement the <a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/cors/reactive/CorsConfigurationSource.html"><code>CorsConfigurationSource</code></a>
interface in order to provide a <a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html">CorsConfiguration</a>
instance for each request.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-http2"><a class="anchor" href="#webflux-http2"></a>1.8. HTTP/2</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-http2">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Servlet 4 containers are required to support HTTP/2 and Spring Framework 5 is compatible
with Servlet API 4. From a programming model perspective there is nothing specific that
applications need to do. However there are considerations related to server configuration.
For more details please check out the
<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 wiki page</a>.</p>
</div>
<div class="paragraph">
<p>Currently Spring WebFlux does not support HTTP/2 with Netty. There is also no support for
pushing resources programmatically to the client.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-client"><a class="anchor" href="#webflux-client"></a>2. WebClient</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>spring-webflux</code> module includes a non-blocking, reactive client for HTTP requests
with Reactive Streams back pressure. It shares
<a href="#webflux-codecs">HTTP codecs</a> and other infrastructure with the
server <a href="#webflux-fn">functional web framework</a>.</p>
</div>
<div class="paragraph">
<p><code>WebClient</code> provides a higher level API over HTTP client libraries. By default
it uses <a href="https://github.com/reactor/reactor-netty">Reactor Netty</a> but that is pluggable
with a different <code>ClientHttpConnector</code>. The <code>WebClient</code> API returns Reactor <code>Flux</code> or
<code>Mono</code> for output and accepts Reactive Streams <code>Publisher</code> as input (see
<a href="#webflux-reactive-libraries">Reactive Libraries</a>).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By comparison to the
<a href="integration.html#rest-resttemplate">RestTemplate</a>, the <code>WebClient</code> offers a more
functional and fluent API that taking full advantage of Java 8 lambdas. It supports both
sync and async scenarios, including streaming, and brings the efficiency of
non-blocking I/O.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="webflux-client-retrieve"><a class="anchor" href="#webflux-client-retrieve"></a>2.1. Retrieve</h3>
<div class="paragraph">
<p>The <code>retrieve()</code> method is the easiest way to get a response body and decode it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    WebClient client = WebClient.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.org</span><span class="delimiter">&quot;</span></span>);

    Mono&lt;Person&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id).accept(MediaType.APPLICATION_JSON)
            .retrieve()
            .bodyToMono(Person.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also get a stream of objects decoded from the response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Flux&lt;Quote&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/quotes</span><span class="delimiter">&quot;</span></span>).accept(MediaType.TEXT_EVENT_STREAM)
            .retrieve()
            .bodyToFlux(Quote.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, responses with 4xx or 5xx status codes result in an error of type
<code>WebClientResponseException</code> but you can customize that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Mono&lt;Person&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id).accept(MediaType.APPLICATION_JSON)
            .retrieve()
            .onStatus(HttpStatus::is4xxServerError, response -&gt; ...)
            .onStatus(HttpStatus::is5xxServerError, response -&gt; ...)
            .bodyToMono(Person.class);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-exchange"><a class="anchor" href="#webflux-client-exchange"></a>2.2. Exchange</h3>
<div class="paragraph">
<p>The <code>exchange()</code> method provides more control. The below example is equivalent
to <code>retrieve()</code> but also provides access to the <code>ClientResponse</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Mono&lt;Person&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id).accept(MediaType.APPLICATION_JSON)
            .exchange()
            .flatMap(response -&gt; response.bodyToMono(Person.class));</code></pre>
</div>
</div>
<div class="paragraph">
<p>At this level you can also create a full <code>ResponseEntity</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Mono&lt;ResponseEntity&lt;Person&gt;&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id).accept(MediaType.APPLICATION_JSON)
            .exchange()
            .flatMap(response -&gt; response.toEntity(Person.class));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that unlike <code>retrieve()</code>, with <code>exchange()</code> there are no automatic error signals for
4xx and 5xx responses. You have to check the status code and decide how to proceed.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When using <code>exchange()</code> you must always use any of the body or toEntity methods of
<code>ClientResponse</code> to ensure resources are released and to avoid potential issues with HTTP
connection pooling. You can use <code>bodyToMono(Void.class)</code> if no response content is
expected. However keep in mind that if the response does have content, the connection
will be closed and will not be placed back in the pool.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-body"><a class="anchor" href="#webflux-client-body"></a>2.3. Request body</h3>
<div class="paragraph">
<p>The request body can be encoded from an Object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Mono&lt;Person&gt; personMono = ... ;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id)
            .contentType(MediaType.APPLICATION_JSON)
            .body(personMono, Person.class)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also have a stream of objects encoded:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Flux&lt;Person&gt; personFlux = ... ;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id)
            .contentType(MediaType.APPLICATION_STREAM_JSON)
            .body(personFlux, Person.class)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or if you have the actual value, use the <code>syncBody</code> shortcut method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Person person = ... ;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id)
            .contentType(MediaType.APPLICATION_JSON)
            .syncBody(person)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-form"><a class="anchor" href="#webflux-client-body-form"></a>2.3.1. Form data</h4>
<div class="paragraph">
<p>To send form data, provide a <code>MultiValueMap&lt;String, String&gt;</code> as the body. Note that the
content is automatically set to <code>"application/x-www-form-urlencoded"</code> by the
<code>FormHttpMessageWriter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    MultiValueMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; formData = ... ;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, id)
            .syncBody(formData)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also supply form data in-line via <code>BodyInserters</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.BodyInserters</span>.*;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, id)
            .body(fromFormData(<span class="string"><span class="delimiter">&quot;</span><span class="content">k1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">v1</span><span class="delimiter">&quot;</span></span>).with(<span class="string"><span class="delimiter">&quot;</span><span class="content">k2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">v2</span><span class="delimiter">&quot;</span></span>))
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-multipart"><a class="anchor" href="#webflux-client-body-multipart"></a>2.3.2. Multipart data</h4>
<div class="paragraph">
<p>To send multipart data, provide a <code>MultiValueMap&lt;String, ?&gt;</code> where values are either an
Object representing the part body, or an <code>HttpEntity</code> representing the part body and
headers. <code>MultipartBodyBuilder</code> can be used to build the parts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    MultipartBodyBuilder builder = <span class="keyword">new</span> MultipartBodyBuilder();
    builder.part(<span class="string"><span class="delimiter">&quot;</span><span class="content">fieldPart</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">fieldValue</span><span class="delimiter">&quot;</span></span>);
    builder.part(<span class="string"><span class="delimiter">&quot;</span><span class="content">filePart</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> FileSystemResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">...logo.png</span><span class="delimiter">&quot;</span></span>));
    builder.part(<span class="string"><span class="delimiter">&quot;</span><span class="content">jsonPart</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Jason</span><span class="delimiter">&quot;</span></span>));

    MultiValueMap&lt;<span class="predefined-type">String</span>, HttpEntity&lt;?&gt;&gt; parts = builder.build();

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, id)
            .syncBody(parts)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the content type for each part is automatically set based on the extension of the
file being written or the type of Object. If you prefer you can also be more explicit and
specify the content type for each part.</p>
</div>
<div class="paragraph">
<p>You can also supply multipart data in-line via <code>BodyInserters</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.BodyInserters</span>.*;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, id)
            .body(fromMultipartData(<span class="string"><span class="delimiter">&quot;</span><span class="content">fieldPart</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>).with(<span class="string"><span class="delimiter">&quot;</span><span class="content">filePart</span><span class="delimiter">&quot;</span></span>, resource))
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-builder"><a class="anchor" href="#webflux-client-builder"></a>2.4. Builder options</h3>
<div class="paragraph">
<p>A simple way to create <code>WebClient</code> is through the static factory methods <code>create()</code> and
<code>create(String)</code> with a base URL for all requests. You can also use <code>WebClient.builder()</code>
for access to more options.</p>
</div>
<div class="paragraph">
<p>To customize the underlying HTTP client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    SslContext sslContext = ...

    ClientHttpConnector connector = <span class="keyword">new</span> ReactorClientHttpConnector(
            builder -&gt; builder.sslContext(sslContext));

    WebClient webClient = WebClient.builder()
            .clientConnector(connector)
            .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>To customize the <a href="#webflux-codecs">HTTP codecs</a> used for encoding and
decoding HTTP messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    ExchangeStrategies strategies = ExchangeStrategies.builder()
            .codecs(configurer -&gt; {
                <span class="comment">// ...</span>
            })
            .build();

    WebClient webClient = WebClient.builder()
            .exchangeStrategies(strategies)
            .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The builder can be used to insert <a href="#webflux-client-filter">Filters</a>.</p>
</div>
<div class="paragraph">
<p>Explore the <code>WebClient.Builder</code> in your IDE for other options related to URI building,
default headers (and cookies), and more.</p>
</div>
<div class="paragraph">
<p>After the <code>WebClient</code> is built, you can always obtain a new builder from it, in order to
build a new <code>WebClient</code>, based on, but without affecting the current instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    WebClient modifiedClient = client.mutate()
            <span class="comment">// user builder methods...</span>
            .build();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-filter"><a class="anchor" href="#webflux-client-filter"></a>2.5. Filters</h3>
<div class="paragraph">
<p><code>WebClient</code> supports interception style request filtering:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    WebClient client = WebClient.builder()
            .filter((request, next) -&gt; {
                ClientRequest filtered = ClientRequest.from(request)
                        .header(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>)
                        .build();
                <span class="keyword">return</span> next.exchange(filtered);
            })
            .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ExchangeFilterFunctions</code> provides a filter for basic authentication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// static import of ExchangeFilterFunctions.basicAuthentication</span>

    WebClient client = WebClient.builder()
            .filter(basicAuthentication(<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">pwd</span><span class="delimiter">&quot;</span></span>))
            .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also mutate an existing <code>WebClient</code> instance without affecting the original:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    WebClient filteredClient = client.mutate()
            .filter(basicAuthentication(<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">pwd</span><span class="delimiter">&quot;</span></span>)
            .build();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-websocket"><a class="anchor" href="#webflux-websocket"></a>3. WebSockets</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket">Same in Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>This part of the reference documentation covers support for Reactive stack, WebSocket
messaging.</p>
</div>
<div class="sect2">
<h3 id="websocket-intro"><a class="anchor" href="#websocket-intro"></a>3.1. Introduction</h3>
<div class="paragraph">
<p>The WebSocket protocol <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a> provides a standardized
way to establish a full-duplex, two-way communication channel between client and server
over a single TCP connection. It is a different TCP protocol from HTTP but is designed to
work over HTTP, using ports 80 and 443 and allowing re-use of existing firewall rules.</p>
</div>
<div class="paragraph">
<p>A WebSocket interaction begins with an HTTP request that uses the HTTP <code>"Upgrade"</code> header
to upgrade, or in this case to switch, to the WebSocket protocol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
<strong>Upgrade: websocket</strong>
<strong>Connection: Upgrade</strong>
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080</pre>
</div>
</div>
<div class="paragraph">
<p>Instead of the usual 200 status code, a server with WebSocket support returns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre><strong>HTTP/1.1 101 Switching Protocols</strong>
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp</pre>
</div>
</div>
<div class="paragraph">
<p>After a successful handshake the TCP socket underlying the HTTP upgrade request remains
open for both client and server to continue to send and receive messages.</p>
</div>
<div class="paragraph">
<p>A complete introduction of how WebSockets work is beyond the scope of this document.
Please read RFC 6455, the WebSocket chapter of HTML5, or one of many introductions and
tutorials on the Web.</p>
</div>
<div class="paragraph">
<p>Note that if a WebSocket server is running behind a web server (e.g. nginx) you will
likely need to configure it to pass WebSocket upgrade requests on to the WebSocket
server. Likewise if the application runs in a cloud environment, check the
instructions of the cloud provider related to WebSocket support.</p>
</div>
<div class="sect3">
<h4 id="websocket-intro-architecture"><a class="anchor" href="#websocket-intro-architecture"></a>3.1.1. HTTP vs WebSocket</h4>
<div class="paragraph">
<p>Even though WebSocket is designed to be HTTP compatible and starts with an HTTP request,
it is important to understand that the two protocols lead to very different
architectures and application programming models.</p>
</div>
<div class="paragraph">
<p>In HTTP and REST, an application is modeled as many URLs. To interact with the application
clients access those URLs, request-response style. Servers route requests to the
appropriate handler based on the HTTP URL, method, and headers.</p>
</div>
<div class="paragraph">
<p>By contrast in WebSockets there is usually just one URL for the initial connect and
subsequently all application messages flow on that same TCP connection. This points to
an entirely different asynchronous, event-driven, messaging architecture.</p>
</div>
<div class="paragraph">
<p>WebSocket is also a low-level transport protocol which unlike HTTP does not prescribe
any semantics to the content of messages. That means there is no way to route or process
a message unless client and server agree on message semantics.</p>
</div>
<div class="paragraph">
<p>WebSocket clients and servers can negotiate the use of a higher-level, messaging protocol
(e.g. STOMP), via the <code>"Sec-WebSocket-Protocol"</code> header on the HTTP handshake request,
or in the absence of that they need to come up with their own conventions.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-intro-when-to-use"><a class="anchor" href="#websocket-intro-when-to-use"></a>3.1.2. When to use it?</h4>
<div class="paragraph">
<p>WebSockets can make a web page dynamic and interactive. However in many cases
a combination of Ajax and HTTP streaming and/or long polling could provide a simple and
effective solution.</p>
</div>
<div class="paragraph">
<p>For example news, mail, and social feeds need to update dynamically but it may be
perfectly okay to do so every few minutes. Collaboration, games, and financial apps on
the other hand need to be much closer to real time.</p>
</div>
<div class="paragraph">
<p>Latency alone is not a deciding factor. If the volume of messages is relatively low (e.g.
monitoring network failures) HTTP streaming or polling may provide an effective solution.
It is the combination of low latency, high frequency and high volume that make the best
case for the use WebSocket.</p>
</div>
<div class="paragraph">
<p>Keep in mind also that over the Internet, restrictive proxies  outside your control,
may preclude WebSocket interactions either because they are not configured to pass on the
<code>Upgrade</code> header or because they close long lived connections that appear idle? This
means that the use of WebSocket for internal applications within the firewall is a more
straight-forward decision than it is for public facing applications.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-server"><a class="anchor" href="#webflux-websocket-server"></a>3.2. WebSocket API</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server">Same in Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>The Spring Framework provides a WebSocket API that can be used to write client and
server side applications that handle WebSocket messages.</p>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-handler"><a class="anchor" href="#webflux-websocket-server-handler"></a>3.2.1. WebSocketHandler</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-handler">Same in Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>Creating a WebSocket server is as simple as implementing <code>WebSocketHandler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.web.reactive.socket.WebSocketHandler</span>;
<span class="keyword">import</span> <span class="include">org.springframework.web.reactive.socket.WebSocketSession</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">MyWebSocketHandler</span> <span class="directive">implements</span> WebSocketHandler {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; handle(WebSocketSession session) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring WebFlux provides a <code>WebSocketHandlerAdapter</code> that can adapt WebSocket
requests and use the above handler to handle the resulting WebSocket session. After the
adapter is registered as a bean, you can map requests to your handler, for example using
<code>SimpleUrlHandlerMapping</code>. This is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">static</span> <span class="type">class</span> <span class="class">WebConfig</span> {

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> HandlerMapping handlerMapping() {
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, WebSocketHandler&gt; map = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();
        map.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> MyWebSocketHandler());

        SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();
        mapping.setUrlMap(map);
        mapping.setOrder(-<span class="integer">1</span>); <span class="comment">// before annotated controllers</span>
        <span class="keyword">return</span> mapping;
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> WebSocketHandlerAdapter handlerAdapter() {
        <span class="keyword">return</span> <span class="keyword">new</span> WebSocketHandlerAdapter();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-handshake"><a class="anchor" href="#webflux-websocket-server-handshake"></a>3.2.2. WebSocket Handshake</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-handshake">Same in Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p><code>WebSocketHandlerAdapter</code> does not perform WebSocket handshakes itself. Instead it
delegates to an instance of <code>WebSocketService</code>. The default <code>WebSocketService</code>
implementation is <code>HandshakeWebSocketService</code>.</p>
</div>
<div class="paragraph">
<p>The <code>HandshakeWebSocketService</code> performs basic checks on the WebSocket request and
delegates to a server-specific <code>RequestUpgradeStrategy</code>. At present upgrade strategies
exist for Reactor Netty, Tomcat, Jetty, and Undertow.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-config"><a class="anchor" href="#webflux-websocket-server-config"></a>3.2.3. Server config</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-runtime-configuration">Same in Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>The <code>RequestUpgradeStrategy</code> for each server exposes the WebSocket-related configuration
options available for the underlying WebSocket engine. Below is an example of setting
WebSocket options when running on Tomcat:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">static</span> <span class="type">class</span> <span class="class">WebConfig</span> {

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> WebSocketHandlerAdapter handlerAdapter() {
        <span class="keyword">return</span> <span class="keyword">new</span> WebSocketHandlerAdapter(webSocketService());
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> WebSocketService webSocketService() {
        TomcatRequestUpgradeStrategy strategy = <span class="keyword">new</span> TomcatRequestUpgradeStrategy();
        strategy.setMaxSessionIdleTimeout(<span class="integer">0L</span>);
        <span class="keyword">return</span> <span class="keyword">new</span> HandshakeWebSocketService(strategy);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check the upgrade strategy for your server to see what options are available. Currently
only Tomcat and Jetty expose such options.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-cors"><a class="anchor" href="#webflux-websocket-server-cors"></a>3.2.4. CORS</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-allowed-origins">Same in Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>The easiest way to configure CORS and restrict access to a WebSocket endpoint is to
have your <code>WebSocketHandler</code> implement <code>CorsConfigurationSource</code> and return a
<code>CorsConfiguraiton</code> with allowed origins, headers, etc. If for any reason you can&#8217;t do
that, you can also set the <code>corsConfigurations</code> property on the <code>SimpleUrlHandler</code> to
specify CORS settings by URL pattern. If both are specified they&#8217;re combined via the
<code>combine</code> method on <code>CorsConfiguration</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-client"><a class="anchor" href="#webflux-websocket-client"></a>3.3. WebSocketClient</h3>
<div class="paragraph">
<p>Spring WebFlux provides a <code>WebSocketClient</code> abstraction with implementations for
Reactor Netty, Tomcat, Jetty, Undertow, and standard Java (i.e. JSR-356).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Tomcat client is effectively an extension of the standard Java one with some extra
functionality in the <code>WebSocketSession</code> handling taking advantage of Tomcat specific
API to suspend receiving messages for back pressure.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To start a WebSocket session, create an instance of the client and use its <code>execute</code>
methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebSocketClient client = <span class="keyword">new</span> ReactorNettyWebSocketClient();

<span class="predefined-type">URI</span> url = <span class="keyword">new</span> <span class="predefined-type">URI</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">ws://localhost:8080/path</span><span class="delimiter">&quot;</span></span>);
client.execute(url, session -&gt;
        session.receive()
                .doOnNext(<span class="predefined-type">System</span>.out::println)
                .then());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some clients, e.g. Jetty, implement <code>Lifecycle</code> and need to be started in stopped
before you can use them. All clients have constructor options related to configuration
of the underlying WebSocket client.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-test"><a class="anchor" href="#webflux-test"></a>4. Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>spring-test</code> module provides mock implementations of <code>ServerHttpRequest</code>,
<code>ServerHttpResponse</code>, and <code>ServerWebExchange</code>.
See <a href="testing.html#mock-objects-web-reactive">Spring Web Reactive</a> mock objects.</p>
</div>
<div class="paragraph">
<p>The <a href="testing.html#webtestclient">WebTestClient</a> builds on these mock request and
response objects to provide support for testing WebFlux applications without and HTTP
server. The <code>WebTestClient</code> can be used for end-to-end integration tests too.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-reactive-libraries"><a class="anchor" href="#webflux-reactive-libraries"></a>5. Reactive Libraries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactor is a required dependency for the <code>spring-webflux</code> module and is used internally
for composing logic and for Reactive Streams support. An easy rule to remember is that
WebFlux APIs return <code>Flux</code> or <code>Mono</code>&#8201;&#8212;&#8201;since that&#8217;s what&#8217;s used internally, and
leniently accept any Reactive Streams <code>Publisher</code> implementation.</p>
</div>
<div class="paragraph">
<p>The use of <code>Flux</code> and <code>Mono</code> helps to express cardinality&#8201;&#8212;&#8201;e.g.
whether a single or multiple async values are expected. This is important for API design
but also essential in some cases, e.g. when encoding an HTTP message.</p>
</div>
<div class="paragraph">
<p>For annotated controllers, WebFlux adapts transparently to the reactive library in use
with proper translation of cardinality. This is done with the help of the
<a href="https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html">ReactiveAdapterRegistry</a> from
<code>spring-core</code> which provides pluggable support for reactive and async types. The registry
has built-in support for RxJava and <code>CompletableFuture</code> but others can be registered.</p>
</div>
<div class="paragraph">
<p>For functional endpoints, the <code>WebClient</code>, and other functional APIs, the general rule
of thumb for WebFlux APIs applies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Flux</code> or <code>Mono</code> as return values&#8201;&#8212;&#8201;use them to compose logic or pass to any Reactive
Streams library (both are <code>Publisher</code> implementations).</p>
</li>
<li>
<p>Reactive Streams <code>Publisher</code> for input&#8201;&#8212;&#8201;if a <code>Publisher</code> from another reactive library
is provided it can only be treated as a stream with unknown semantics (0..N). If the
semantics are known&#8201;&#8212;&#8201;e.g. <code>io.reactivex.Single</code>, you can use <code>Mono.from(Publisher)</code> and
pass that in instead of the raw <code>Publisher</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For example, given a <code>Publisher</code> that is not a <code>Mono</code>, the Jackson JSON message writer
expects multiple values. If the media type implies an infinite stream&#8201;&#8212;&#8201;e.g.
<code>"application/json+stream"</code>, values are written and flushed individually; otherwise
values are buffered into a list and rendered as a JSON array.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.0.2.RELEASE<br>
Last updated 2017-11-27 10:24:45 UTC
</div>
</div>
<script src="tocbot-3.0.2/tocbot.js"></script>
<script>

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();


    var link = document.createElement("a");
    link.setAttribute("href", "index.html");
    link.innerHTML = "<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";
    var p = document.createElement("p");
    p.appendChild(link);
    var toc = document.getElementById('toc')
    var next = document.getElementById('toctitle').nextElementSibling;
    toc.insertBefore(p, next);

</script>
</body>
</html>